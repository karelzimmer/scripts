Deel 3. Functies

Oefeningen met functies en lambdas
Werken met aparte module
Foutafhandeling
Reguliere expressies (extra)
Extra oefeningen


[1] Functies en lambdas

Als er veel code in een module staat, wordt het geheel nogal onoverzichtelijk. Het is dan verstandig de code onder te verdelen in functies. Een functie is een stukje code met een naam en eventuele argumenten. Je definieert hem met het woordje def. De code binnen een functie moet inspringen. Gebruik return als een functie iets teruggeeft.

1. Maak een nieuwe module ex3_functies.py. Zet daarin als commentaar: Functies.
Definieer in de module de functie telop(). Deze krijgt twee argumenten a en b mee. Hij retourneert de som van de argumenten.

2. Schrijf een eindje onder de functie het commentaar: --- script ---.
Roep telop() aan met als argumenten 5 en 7. Zet de return-waarde in c. Druk c af met print(). Sla op en test.
Is het ook mogelijk in het print()-statement de functie telop() aan te roepen? Probeer dit uit met de argumenten 2 en 3*4.
Roep telop() aan met de argumenten "boeken" en "bal" en druk de uitkomst af.
Roep telop() aan met de argumenten 3 en "boeken" en druk de uitkomst af.

3. Maak nu onder telop(), maar boven het script, een nieuwe functie bereken(). Deze krijgt twee getallen a en b mee, en een string-variabele optor. Hierin zet je welk soort berekening hij moet uitvoeren: "+", "-", "*", "/". De functie moet de juiste berekening uitvoeren en de uitkomst retourneren.
Ga naar het script en maak commentaar van de vorige aanroep. Roep bereken() aan met 5, 7 en "*". Zet de uitkomst in c. Druk c af. Probeer de functie ook met andere getallen en berekeningen.

4. Maak een nieuwe functie fac(), die als argument het getal a meekrijgt. De functie berekent de faculteit van een getal: fac(3) is 1*2*3, fac(4) is 1*2*3*4, enz. Retourneer de uitkomst. Gebruik binnen fac() een while-lus.
Ga naar het script en maak commentaar van de vorige aanroep. Roep fac() aan met 4 en druk de uitkomst af. Test daarna met 6 en 8. Een faculteit wordt al snel enorm groot!

5. Lambda-expressies zijn korte, eenregelige functies zonder naam. Ze worden vaak als argument aan een andere functie meegegeven, maar je kunt ze ook in een variabele stoppen.
Maak net boven het script de variabele trekaf en zet daarin een lambda die twee getallen a en b meekrijgt en b van a aftrekt. Zet daaronder evenzo de variabele vermvuld met een lambda die a en b vermenigvuldigt, en deel met een lambda die a deelt door b.
Ga naar het script en maak commentaar van de vorige aanroepen. Roep de drie lambda-variabelen aan alsof het functies zijn met de waarden 13 en 5 en druk de uitkomst af. Test daarna vermvuld met de waarden "ojee " en 3.

6. Het is ook mogelijk een functie binnen een andere functie te definiëren. Dit wordt veel gebruikt bij z.g. functioneel programmeren, maar ook bij een grafische interface (gui).
Maak boven het script een functie test_funcinfunc(). Definieer daarbinnen de functie inc() die een getal meekrijgt en dat met 1 verhoogd retourneert. Maak daaronder, nog steeds binnen test_funcinfunc(), de functie dec(), die een getal meekrijgt en dit met 1 verlaagd retourneert. Maak daaronder een while-lus. Vraag daarin de gebruiker een geheel getal in te voeren. Druk het getal, de verhoogde en de verlaagde versie af. Gebruik daarvoor de functies inc() en dec(). Als de gebruiker "stop" intypt ipv een getal, moet de lus stoppen.
Ga naar het script en maak commentaar van de vorige aanroepen. Roep test_funcinfunc() aan. inc() en dec() kunnen ook als lambda's gedefinieerd worden. Probeer dit uit.


[2] Module met functies

1. Maak met menu File\New File een nieuwe module datumfuncties.py. Houdt de huidige module open, zodat nu twee modules open staan. Maak nu in datumfuncties.py de functie isSchrikkelJaar(), die een jaar meekrijgt. Hij moet True teruggeven als het een schrikkeljaar betreft, anders False. Maak daaronder de functie getDagenInMaand(), die een maand en jaar meekrijgt. Hij moet het bijpassende aantal dagen in de maand teruggeven. Dus 2, 2000 geeft 29 dagen en 4, 2018 geeft 30 dagen. Deze functie gebruikt isSchrikkelJaar(). Maak daaronder de functie isGeldigeDatum(), die een dag, maand en jaar meekrijgt. Hij gebruikt de vorige functies en geeft bij geldige datum True terug, anders False.
Sla datumfuncties.py op en controleer hem met Check Module in het menu Run.

2. Ga naar ex3_functies.py. Zet bovenin, onder het commentaar, code om datumfuncties.py te importeren. Definieer net boven het script de functie test_datumfuncties(). Vul de variabelen dag, maand, jaar met passende getallen. Controleer met isGeldigeDatum() uit de andere module of dit een geldige datum is. Druk de uitkomst af.
Ga naar het script en maak commentaar van de vorige aanroepen. Roep test_datumfuncties aan. Test.
Je kunt de output mooier maken door bijvoorbeeld af te laten drukken: "16-4-2017 is een geldige datum". Probeer dit uit.

Het is mogelijk in Python een hele directorystructuur met modules te maken en daaraan speciale initialisatiemodules toe te voegen. Dit zijn packages. De in Python ingebouwde packages kun je vinden in de directory: <pythondir>\Lib. De met pip opghaalde packages komen in de subdirectory site-packages. Packages worden in de cursus verder niet behandeld.


[3] Gestructureerde foutafhandeling (runtime exception handling)

Vaak treden er tijdens de uitvoering van een programma fouten op doordat de gebruiker verkeerde gegevens invoert, of in het programma per ongeluk door 0 wordt gedeeld. Met gestructureerde foutafhandeling voorkom je dat het programma crasht.

1. Maak in ex3_functies.py net boven het script een nieuwe functie test_delen(). Vraag daarin de
gebruiker twee getallen in te voeren. Converteer de invoer naar int en stop de resultaten in de variabele a en b. Deel a door b en zet de uitkomst in c. Druk c af. Druk daaronder af "klaar".
Ga naar het script en maak commentaar van de vorige code. Test de functie met als invoer 8 en 3. Daarna met 8 en 'drie'. Daarna met 8 en 0. Welke runtime errors treden op?

2. Kopieer de functie naar test_delen_ex() en voeg aan de nieuwe functie exception handling toe voor de juiste errors. Druk de opgetreden errors af. Test deze functie met dezelfde invoer.

3. Maak een kopie van de oude functie bereken() en noem deze bereken_ex(). Ook deze versie krijgt drie argumenten a, b, optor mee. Wijzig deze functie. Als de gebruiker een andere operator meegeeft dan "+", "-", "*", "/", moet hij een ValueError genereren met daarin de tekst "Ongeldige operator: '..'" en op de plaats van de puntjes de gewraakte operator.
Maak daaronder een functie test_bereken_ex(). Roep daarin bereken_ex() aan met 5, 7 en '*' en druk de uitkomst af. Ga naar het script en voeg onderin een aanroep van test_bereken_ex() toe. Test. 

4. Wijzig test_bereken_ex() en maak van de operator '*' een '^'. Test opnieuw. Voeg aan test_bereken_ex() foutafhandeling toe en druk daarin de opgetreden fout af. Test opnieuw met optor '^'. Test vervolgens met 5, 0, '/'. Voeg foutafhandeling toe voor de nu optredende error. Hoe kun je twee soorten errors afvangen met één except? Test.


[4] Reguliere expressies (indien er tijd over is)

Alle moderne programmeertalen hebben functionaliteit om woorden of woordpatronen te zoeken in een tekst en deze eventueel te vervangen door iets anders. Zo'n woordpatroon heet een reguliere expressie, vaak afgekort tot regex. Ze worden vaak gebruikt om te controleren of een datum, postcode, of email geldig is. Python heeft hiervoor de module re. Reguliere expressies kunnen buitengewoon ingewikkeld worden. We beperken ons tot eenvoudige oefeningen.

1. Importeer bovenin ex3_functies.py de Python module re. Maak net boven het script een nieuwe functie regex_pcode(). Declareer daarin de variabele pcode met waarde "3022 BF". Declareer daaronder de variabele pat met een regex-patroon dat controleert of pcode een geldige postcode bevat: 4 cijfers, een spatie, en twee hoofdletters. Om problemen met \ te vermijden is het handig deze patroon-string als raw string op te geven. Controleer met re.fullmatch() of pcode geldig is en zet de uitkomst in de variabele m. Druk m af. Druk m.group() af.

Commentarieer in het script alle aanroepen uit en roep regex_pcode() aan. Test. Wijzig pcode in "3022 BFF" en test opnieuw. Wat zit er nu in variabele m? Wijzig de functie. Druk niet langer m en m.group() af, maar controleer met een if-statement of m geldig is; zoja, druk pcode af met daarachter " is een geldige postcode", anders " is een ongeldige postcode". Test.

2. Wijzig het regex-patroon. Het eerste cijfer mag niet "0" zijn. Verder mag de spatie eventueel worden weggelaten. Test met verschillende postcodes, geldig en ongeldig.
Wat is het verschil tussen de functies re.fullmatch(), re.match() en re.search()?

3. Maak een nieuwe functie regex_datum(). Declareer daarin de variabele datum met waarde "23/05/2019". Declareer daaronder de variabele pat met een regex-patroon dat controleert of de datum geldig is; het scheidingsteken mag "/" of "-" zijn, dag en maand moeten 2 cijfers tellen en jaar 4 cijfers. Controleer met re.fullmatch() of de datum geldig is en druk dit af.
Roep in het script deze functie aan. Test.

4. Wijzig in de functie het regex-patroon. Het scheidingsteken moet 2 keer "/" of "-" zijn, zodat bv "23/05-2019" een ongeldige datum wordt. Dit gaat het makkelijkst met een zg back reference. Test.

5. Maak een nieuwe functie regex_vervang(). Declareer daarin de variabele s met tekst "O. wat. is. dit. leuk." Verwijder mbv een regex functie alle punten uit s en druk het resultaat af. Roep in het script deze functie aan en test.
Wijzig de functie. Zorg dat de laatste punt blijft staan. Test.


[5] Extra oefeningen met functies (voor de snelle cursisten)

1. Maak net boven het script een nieuwe functie interpoleer(). Deze krijgt vijf argumenten mee, waarmee een getal wordt omgerekend van de ene schaal in de andere. Denk aan een omrekening van temperatuur van fahrenheit in celsius, of van kleurwaarden in het bereik 0 - 255 naar 0 - 100 procent. De argumenten zijn: getal, min1 en max1 voor de oude schaal, en min2 en max2 voor de nieuwe schaal. De functie moet de juiste waarde van het getal in de nieuwe schaal teruggeven. Als getal onder min1 ligt, wordt de uitkomst negatief. Bijvoorbeeld: 32 fahrenheit is 0 celsius en 212 fahrenheit is 100 celsius. Hoeveel graden celsius is 47 fahrenheit? Roep de functie aan met interpoleer(47, 32,212, 0,100). Het antwoord luidt: 8.33 in celsius. Zo wordt 0 fahrenheit -17.77 celsius.

Commentarieer in het script alle aanroepen uit. Test interpoleer() met verschillende getallen en bereiken. Hoeveel celsius wordt -40 fahrenheit? De min- en max-waarden mogen ook negatief zijn. Zo moet interpoleer(10, -20,20, 0,40) de waarde 30.0 opleveren. Omrekenen van radians in graden kan ook: interpoleer(1, 0,math.pi, 0,180) geeft 57.2957 graden. Probeer dit uit.

2. We hebben een functie inc() gemaakt die een meegegeven getal met 1 verhoogt. Je kunt ook een functie maken die een andere functie retourneert. De eerste functie krijgt een argument mee, waarmee de tweede functie steeds een getal moet verhogen. De tweede functie onthoudt automatisch het argument van de eerste functie. Dit heet in functioneel programmeren een closure.
Definieer net boven het script de functie maak_verhoog(). Deze krijgt een verhogingswaarde a mee. Definieer binnen deze functie de functie verhoog(), die als argument getal meekrijgt. Tel binnen deze functie getal en a op en retourneer het resultaat. Retourneer daaronder in de buitenste functie de functie verhoog met de code: return verhoog. Let op: je moet verhoog zelf teruggeven, niet een aanroep van verhoog; gebruik daarom geen haakjes!

Maak nu een functie test_maak_verhoog(). De volgende code komt allemaal in test_maak_verhoog(). Roep maak_verhoog() aan met als argument 2. Zet de returnwaarde in de variabele inc2; dit wordt een function pointer. Roep inc2() aan met waarde 5 en druk het resultaat af. Zet daaronder de uitkomst van inc2() met waarde 0. Roep daaronder maak_verhoog() aan met waarde 5 en zet de uitkomst in variabele inc5. Dit wordt een tweede function pointer. Roep een paar keer inc5() aan met andere argumenten en druk steeds de uitkomst af.

Ga naar het script en commentarieer alle aanroepen uit. Roep test_maak_verhoog() aan en aanschouw het wonder. De in Python ingebouwde module functools bevat onder meer de functie partial(). Dat is een geavanceerde, generieke vorm van onze maak_verhoog().

3. Het is mogelijk met code informatie te achterhalen over de functie verhoog() binnen maak_verhoog(). Ga naar test_maak_verhoog() en voeg daarin onderaan code toe. Druk af: inc2.__code__.co_name, daaronder: inc2.__code__.co_varnames, daaronder: inc2.__code__.co_freevars. Test.


===========

Python laatste 32-bit versie voor winxp: 3.4.4
Vanaf 3.5 heb je Windows 7 of later nodig.

download:
www.python.org, tab Downloads

Grote Download-knop -> 64bits Python: python-3.9.2-amd64.exe.
Alleen voor Windows 10.

Werk je op Windows 7, dan moet je een 3.8 versie installeren
Windows 64bits Python: klik op Windows-linkje en dan bij 3.8.8 de x86-64 executable installer downloaden.
Wordt Python-3.8.8-amd64.exe.
Voor de Mac is het altijd 64bits.


Installeren voor huidige gebruiker om prb met extra libraries te voorkomen (rechten).
Evt install-dir wijzigen.

ncoi: python.exe zit soms in:
C:\Users\Cursist\AppData\Local\Programs\Python\Python37

==============

ncoi: pip zit in:
C:\Users\Cursist\AppData\Local\Programs\Python\Python37\Scripts
[ecr: vanaf 3.4 heb je deze aparte pip.exe]

>pip install xyz
>pip install --upgrade xyz

haalt data uit PyPI (=Python Package Index):
https://pypi.python.org/pypi

ncoi: imports komen in:
C:\Users\Cursist\AppData\Local\Programs\Python\Python37\Lib\site-packages

wheel downloaden voor windows, met al gecompileerde binaries:

https://www.lfd.uci.edu/~gohlke/pythonlibs/

en daarna:
>pip install Pillow-4.1.1-cp34-cp34m-win32.whl

lijst v achteraf geinstalleerde modules/libraries:
>pip freeze
>pip list
>pip show lxml

alle modules via shell:
help('modules')

in code:
import pip
for lib in pip.get_installed_distributions(local_only=True):
    print(lib)

===========

https://packaging.python.org/installing/

Upgrade pip, setuptools, and wheel

On Windows:
>python -m pip install --upgrade pip		[-U of --upgrade]
of:
>python -m pip install -U pip setuptools

On Linux or OS X:
pip install -U pip setuptools

===========

C:\Python34\Scripts>pip freeze
colorama==0.3.9
coverage==4.4.2
cycler==0.10.0
lxml==3.8.0
matplotlib==2.1.0
matplotlib-tests==2.1.0
mock==2.0.0
numpy==1.13.3+mkl
olefile==0.44
pandas==0.21.0
pbr==3.1.1
Pillow==4.1.1
py==1.5.2
pyparsing==2.2.0
pytest==3.2.5
pytest-cov==2.5.1
python-dateutil==2.6.1
pytz==2017.3
pywin32==221
six==1.11.0
xlrd==1.1.0

=============

C:\Python34\Scripts>pip -h

Usage:   
  pip <command> [options]

Commands:
  install                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  check                       Verify installed packages have compatible dependencies.
  search                      Search PyPI for packages.
  wheel                       Build wheels from your requirements.
  hash                        Compute hashes of package archives.
  completion                  A helper command used for command completion.
  help                        Show help for commands.

General Options:
  -h, --help                  Show help.
  --isolated                  Run pip in an isolated mode, ignoring
                              environment variables and user configuration.
  -v, --verbose               Give more output. Option is additive, and can be
                              used up to 3 times.
  -V, --version               Show version and exit.
  -q, --quiet                 Give less output. Option is additive, and can be
                              used up to 3 times (corresponding to WARNING,
                              ERROR, and CRITICAL logging levels).
  --log <path>                Path to a verbose appending log.
  --proxy <proxy>             Specify a proxy in the form
                              [user:passwd@]proxy.server:port.
  --retries <retries>         Maximum number of retries each connection should
                              attempt (default 5 times).
  --timeout <sec>             Set the socket timeout (default 15 seconds).
  --exists-action <action>    Default action when a path already exists:
                              (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.
  --trusted-host <hostname>   Mark this host as trusted, even though it does
                              not have valid or any HTTPS.
  --cert <path>               Path to alternate CA bundle.
  --client-cert <path>        Path to SSL client certificate, a single file
                              containing the private key and the certificate
                              in PEM format.
  --cache-dir <dir>           Store the cache data in <dir>.
  --no-cache-dir              Disable the cache.
  --disable-pip-version-check
                              Don't periodically check PyPI to determine
                              whether a new version of pip is available for
                              download. Implied with --no-index.

===========

Use pip for Installing

pip docs: https://pip.pypa.io/en/stable/
pip ref guide: https://pip.pypa.io/en/latest/reference/

Soms beter easy_install gebruiken ->Advanced Topics section
Anaconda: ->gebr altijd conda ipv pip

Installing from PyPI

To install the latest version of "SomeProject":
pip install 'SomeProject'
pip install SomeProject

To install a specific version:
pip install 'SomeProject==1.4'

To install greater than or equal to one version and less than another:
pip install 'SomeProject>=1,<2'

To install a version that’s “compatible” with a certain version: [4]
pip install 'SomeProject~=1.4.2'

This means to install any version “==1.4.*” version that’s also “>=1.4.2”.


Source Distributions vs Wheels

pip can install from either Source Distributions (sdist) or Wheels, but if both are present on PyPI, pip will prefer a compatible wheel.

Wheels are a pre-built distribution format that provides faster installation compared to Source Distributions (sdist), especially when a project contains compiled extensions.

If pip does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future.


Upgrading packages

Upgrade an already installed SomeProject to the latest from PyPI.

pip install --upgrade SomeProject		[of: -U]

Installing to the User Site

To install packages that are isolated to the current user, use the --user flag:
pip install --user SomeProject

For more information see the User Installs section from the pip docs.


Requirements files

Install a list of requirements specified in a Requirements File.
pip install -r requirements.txt

Installing from VCS [=Version Control System]
Install a project from VCS in “editable” mode. For a full breakdown of the syntax, see pip’s section on VCS Support.

pip install -e git+https://git.repo/some_pkg.git#egg=SomeProject          # from git
pip install -e hg+https://hg.repo/some_pkg.git#egg=SomeProject            # from mercurial
pip install -e svn+svn://svn.repo/some_pkg/trunk/#egg=SomeProject         # from svn
pip install -e git+https://git.repo/some_pkg.git@feature#egg=SomeProject  # from a branch


Installing from other Indexes

Install from an alternate index
pip install --index-url http://my.package.repo/simple/ SomeProject

Search an additional index during install, in addition to PyPI
pip install --extra-index-url http://my.package.repo/simple SomeProject


Installing from a local src tree

Installing from local src in Development Mode, i.e. in such a way that the project appears to be installed, but yet is still editable from the src tree.
pip install -e <path>

You can also install normally from src
pip install <path>


Installing from local archives

Install a particular source archive file.
pip install ./downloads/SomeProject-1.0.4.tar.gz

Install from a local directory containing archives (and don’t check PyPI)
pip install --no-index --find-links=file:///local/dir/ SomeProject
pip install --no-index --find-links=/local/dir/ SomeProject
pip install --no-index --find-links=relative/dir/ SomeProject


Installing Prereleases

Find pre-release and development versions, in addition to stable versions. By default, pip only finds stable versions.
pip install --pre SomeProject


Installing Setuptools “Extras”

Install setuptools extras.
$ pip install SomePackage[PDF]
$ pip install SomePackage[PDF]==3.0
$ pip install -e .[PDF]==3.0  # editable project in current directory

==========

http://stackoverflow.com/questions/24285508/how-to-use-pip-with-python-3-4-on-windows

I had the same issue. The problem is that pip install tries to use C:\Users(username)\AppData\Local\Temp to unpack. You have to explicitly set those directories to R/W. I still couldn't do it because it was a work laptop and there were some permissions issues with trying to set these directories to R/W. The alternative is to go to your Env Variables, and set both Tmp and Temp to point to a writeable directory such as C:. The installation went fine. I was able to install pip.

The way I stumbled onto this is by not defaulting pip install in my installation. Even though the pip install was failing, the installer was not giving any errors. Removing pip and then trying to manually add it later is what pointed to what was going on.

===========

Create a virtual environment
[ecr: vanaf 3.3 ingebouwd in Python als venv ->hoeft niet te installeren]

virtualenv is a tool to create isolated Python environments.
In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments.

Using venv:
python3 -m venv <DIR>
source <DIR>/bin/activate

Creating Virtual Environments

Python “Virtual Environments” allow Python packages to be installed in an isolated location for a particular application, rather than being installed globally.

Currently, there are two viable tools for creating Python virtual environments:
•venv is available by default in Python 3.3 and later, and installs pip and setuptools into created virtual environments in Python 3.4 and later.

=============

Python all users installatie ->windows registry:
HKLM\SOFTWARE\Python\PythonCore ->enz
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\Python.exe
->default = C:\Python34\python.exe

HKU\S-1-5-21-2725619501-2474873204-1454097950-1001\Software\Python 3.4
HKCU\Software\Python 3.4

HKCR\.py  ->Python.File
HKCR\.pyc ->Python.CompiledFile
HKCR\.pyo ->Python.CompiledFile
HKCR\.pyw ->Python.NoConFile

HKCR\Python.File ->shell\open\command: "C:\windows\py.exe" "%1" %*

vlg horen wsch bij pywin32 / pywincom:
HKLM\SOFTWARE\Classes\Python
HKLM\SOFTWARE\Classes\Python.AXScript.2
HKLM\SOFTWARE\Classes\Python.CompiledFile
HKLM\SOFTWARE\Classes\Python.Dictionary
enz
HKLM\SOFTWARE\Classes\CLSID\{30BD3490-2632-11cf-AD5B-524153480001}
->pythoncom34.dll

=============

http://stackoverflow.com/questions/6434482/python-function-overloading

ecr: nee, er is geen fn/method overloading. Als je opnieuw def't met andere args, krijg je een nwe def vd fn in de plaats van de oude. De enige opties is met default values voor args werken.

Python function overloading

I am making a game where a character needs to shoot a variety of bullets, but how do I write different functions for creating these bullets? For example suppose I have a function that creates a bullet travelling from point A to B with a given speed. I would write a function like this:

    def add_bullet(sprite, start, headto, speed):
        ... Code ...

But I want to write other functions for creating bullets like:

    def add_bullet(sprite, start, direction, speed):
    def add_bullet(sprite, start, headto, spead, acceleration):
    def add_bullet(sprite, script): # For bullets that are controlled by a script
    def add_bullet(sprite, curve, speed): # for bullets with curved paths
    ... And so on ...

No I can't create a Bullet class hierarchy because thats too slow. The actual code for managing bullets is in C and my functions are wrappers around C API.

I know about the keyword arguments but checking for all sorts of combinations of parameters is getting annoying, but default arguments help allot like acceleration=0

You can use "roll-your-own" solution for function overloading. This one is copied from Guido van Rossum's article about multimethods (because there is little difference between mm and overloading in python):

registry = {}

class MultiMethod(object):
    def __init__(self, name):
        self.name = name
        self.typemap = {}
    def __call__(self, *args):
        types = tuple(arg.__class__ for arg in args) # a generator expression!
        function = self.typemap.get(types)
        if function is None:
            raise TypeError("no match")
        return function(*args)
    def register(self, types, function):
        if types in self.typemap:
            raise TypeError("duplicate registration")
        self.typemap[types] = function


def multimethod(*types):
    def register(function):
        name = function.__name__
        mm = registry.get(name)
        if mm is None:
            mm = registry[name] = MultiMethod(name)
        mm.register(types, function)
        return mm
    return register

The usage would be

from multimethods import multimethod
import unittest

# 'overload' makes more sense in this case
overload = multimethod

class Sprite(object):
    pass

class Point(object):
    pass

class Curve(object):
    pass

@overload(Sprite, Point, Direction, int)
def add_bullet(sprite, start, direction, speed):
    # ...

@overload(Sprite, Point, Point, int, int)
def add_bullet(sprite, start, headto, speed, acceleration):
    # ...

@overload(Sprite, str)
def add_bullet(sprite, script):
    # ...

@overload(Sprite, Curve, speed)
def add_bullet(sprite, curve, speed):
    # ...

Most restrictive limitations at the moment are:

    methods are not supported, only functions that are not class members;
    inheritance is not handled;
    kwargs are not supported;
    registering new functions should be done at import time thing is not thread-safe
	
answered Sep 5 '11 at 12:53
Alexander Poluektov
	
+1 for decorators for extending the language in this use case. – Eloims May 8 '13 at 15:18
	
+1 because this is a great idea (and probably what the OP should go with) --- I had never seen a multimethod implementation in Python. – Escualo Feb 27 '14 at 5:56
	
Deferred 2007 PEP python.org/dev/peps/pep-3124/#user-api – Ciro Santilli ???? ??? ??? Jul 14 '15 at 18:51

What you are asking for, is called multiple dispatch. See Julia language examples which demonstrates different types of dispatches.

Python is a dynamically typed language, so the concept of overloading simply does not apply to it. However, all is not lost, since we can create such alternative functions at run-time:

    In programming languages that defer data type identification until run-time the selection among alternative functions must occur at run-time, based on the dynamically determined types of function arguments. Functions whose alternative implementations are selected in this manner are referred to most generally as multimethods. (Wikipedia)

So we should be able to do multimethods in python or, as it is alternatively called, multiple dispatch.
Multiple dispatch

The multimethods are also called multiple dispatch:

    Multiple dispatch or multimethods is the feature of some object-oriented programming languages in which a function or method can be dynamically dispatched based on the run time (dynamic) type of more than one of its arguments. (Wikipedia)

Python does not support this out of the box1. But, as it happens, there is an excellent python package called multipledispatch that does exactly that.
Solution

Here is how we might use multipledispatch2 package to implement your methods:

>>> from multipledispatch import dispatch
>>> from collections import namedtuple  
>>> from types import *  # we can test for lambda type, e.g.:
>>> type(lambda a: 1) == LambdaType
True

>>> Sprite = namedtuple('Sprite', ['name'])
>>> Point = namedtuple('Point', ['x', 'y'])
>>> Curve = namedtuple('Curve', ['x', 'y', 'z'])
>>> Vector = namedtuple('Vector', ['x','y','z'])

>>> @dispatch(Sprite, Point, Vector, int)
... def add_bullet(sprite, start, direction, speed):
...     print("Called Version 1")
...
>>> @dispatch(Sprite, Point, Point, int, float)
... def add_bullet(sprite, start, headto, speed, acceleration):
...     print("Called version 2")
...
>>> @dispatch(Sprite, LambdaType)
... def add_bullet(sprite, script):
...     print("Called version 3")
...
>>> @dispatch(Sprite, Curve, int)
... def add_bullet(sprite, curve, speed):
...     print("Called version 4")
...

>>> sprite = Sprite('Turtle')
>>> start = Point(1,2)
>>> direction = Vector(1,1,1)
>>> speed = 100 #km/h
>>> acceleration = 5.0 #m/s
>>> script = lambda sprite: sprite.x * 2
>>> curve = Curve(3, 1, 4)
>>> headto = Point(100, 100) # somewhere far away

>>> add_bullet(sprite, start, direction, speed)
Called Version 1

>>> add_bullet(sprite, start, headto, speed, acceleration)
Called version 2

>>> add_bullet(sprite, script)
Called version 3

>>> add_bullet(sprite, curve, speed)
Called version 4

1. Python 3 currently supports single dispatch

2. Take care not to use multipledispatch in a multi-threaded environment, or you will get weird behavior.
shareimprove this answer
	
edited Dec 3 '15 at 19:51
	
This type of behaviour is typically solved (in OOP languages) using Polymorphism. Each type of bullet would be responsible for knowing how it travels. For instance:

class Bullet(object):
    def __init__(self):
        self.curve = None
        self.speed = None
        self.acceleration = None
        self.sprite_image = None

class RegularBullet(Bullet):
    def __init__(self):
        super(RegularBullet, self).__init__()
        self.speed = 10

class Grenade(Bullet):
    def __init__(self):
        super(Grenade, self).__init__()
        self.speed = 4
        self.curve = 3.5

add_bullet(Grendade())

def add_bullet(bullet):
    c_function(bullet.speed, bullet.curve, bullet.acceleration, bullet.sprite, bullet.x, bullet.y) 


void c_function(double speed, double curve, double accel, char[] sprite, ...) {
    if (speed != null && ...) regular_bullet(...)
    else if (...) curved_bullet(...)
    //..etc..
}

Pass as many arguments to the c_function that exist, then do the job of determining which c function to call based on the values in the initial c function. So, python should only ever be calling the one c function. That one c function looks at the arguments, and then can delegate to other c functions appropriately.

You're essentially just using each subclass as a different data container, but by defining all the potential arguments on the base class, the subclasses are free to ignore the ones they do nothing with.

When a new type of bullet comes along, you can simply define one more property on the base, change the one python function so that it passes the extra property, and the one c_function that examines the arguments and delegates appropriately. Doesn't sound too bad I guess.
shareimprove this answer
	
edited Jun 22 '11 at 4:25
	
Maybe there are other ways to improve the performance, but I am much better with C than with Python. The problem was calculating the motions of the bullets and detecting when they go out of screen bounds. I had a methods for calculating position of the bullet pos+v*t and then comparing to screen boundaries if x > 800 and so on. Calling these functions several hundred times per frame turned out to be unacceptably slow. It was something like 40 fps at 100% cpu with pure python to 60 fps with 5%-10% when done in C. – Bullets Jun 22 '11 at 4:03
   	 
	
@Bullets, fair enough then. I'd still use the approach I went with for encapsulating data. Pass an instance of bullet to add_bullet, and extract all the fields that you need. I'll edit my answer. – Josh Smeaton Jun 22 '11 at 4:13

A possible option is to use the multipledispatch module as detailed here: http://matthewrocklin.com/blog/work/2014/02/25/Multiple-Dispatch/

Instead of doing this:

def add(self, other):
    if isinstance(other, Foo):
        ...
    elif isinstance(other, Bar):
        ...
    else:
        raise NotImplementedError()

You can do this:

from multipledispatch import dispatch
@dispatch(int, int)
def add(x, y):
    return x + y    

@dispatch(object, object)
def add(x, y):
    return "%s + %s" % (x, y)

with resulting usage:

>>> add(1, 2)
3

>>> add(1, 'hello')
'1 + hello'

Can you elaborate on this? I tried to create a class hierarchy with different bullets but this does not work, because Python is too slow. It can't calculate the motions of the required number of bullets fast enough, so I had to write that part in C. All the add_bullet variants just call the corresponding C function. – Bullets Jun 22 '11 at 3:24

The following should work for classes. It works by distinguishing by the number of non keyword arguments (but doesn't support distinguishing by type):

class TestOverloading(object):
    def overloaded_function(self, *args, **kwargs):
        # Call the function that has the same number of non-keyword arguments.  
        getattr(self, "_overloaded_function_impl_" + str(len(args)))(*args, **kwargs)

    def _overloaded_function_impl_3(self, sprite, start, direction, **kwargs):
        print "This is overload 3"
        print "Sprite: %s" % str(sprite)
        print "Start: %s" % str(start)
        print "Direction: %s" % str(direction)

    def _overloaded_function_impl_2(self, sprite, script):
        print "This is overload 2"
        print "Sprite: %s" % str(sprite)
        print "Script: "
        print script

And it can be used simply like this:

test = TestOverloading()

test.overloaded_function("I'm a Sprite", 0, "Right")
print
test.overloaded_function("I'm another Sprite", "while x == True: print 'hi'")

Output:

    This is overload 3
    Sprite: I'm a Sprite
    Start: 0
    Direction: Right

    This is overload 2
    Sprite: I'm another Sprite
    Script:
    while x == True: print 'hi'

In Python 3.4 was added PEP-0443. Single-dispatch generic functions.

Here is short API description from PEP.

To define a generic function, decorate it with the @singledispatch decorator. Note that the dispatch happens on the type of the first argument. Create your function accordingly:

from functools import singledispatch
@singledispatch
def fun(arg, verbose=False):
    if verbose:
        print("Let me just say,", end=" ")
    print(arg)

To add overloaded implementations to the function, use the register() attribute of the generic function. This is a decorator, taking a type parameter and decorating a function implementing the operation for that type:

@fun.register(int)
def _(arg, verbose=False):
    if verbose:
        print("Strength in numbers, eh?", end=" ")
    print(arg)

@fun.register(list)
def _(arg, verbose=False):
    if verbose:
        print("Enumerate this:")
    for i, elem in enumerate(arg):
        print(i, elem)

I think a Bulletclass hierarchy with the associated polymorphism is the way to go. You can effectively overload the base class constructor by using a metaclass so that calling the base class results in the creation of the appropriate subclass object. Below is some sample code to illustrate the essence of what I mean.

class BulletMeta(type):
    def __new__(cls, classname, bases, classdict):
        """ Create Bullet class or a subclass of it. """
        classobj = type.__new__(cls, classname, bases, classdict)
        if classname == 'Bullet':  # base class definition?
            classobj.registry = {}  # initialize class registry
        else:
            try:
                alias = classdict['alias']
            except KeyError:
                raise TypeError("Bullet subclass %s has no 'alias'" %
                                classname)
            if alias in Bullet.registry: # unique?
                raise TypeError("Bullet subclass %s's alias attribute "
                                "%r already in use" % (classname, alias))
            # register subclass under the specified alias
            classobj.registry[alias] = classobj

        return classobj

    # instance factory for subclasses
    # subclasses should only be instantiated by calls to the base class
    # with their subclass's alias as the first arg
    def __call__(cls, alias, *args, **kwargs):
        if cls != Bullet:
            raise TypeError("Bullet subclass %r objects should not to "
                            "be explicitly constructed." % cls.__name__)
        elif alias not in cls.registry: # Bullet subclass?
            raise NotImplementedError("Unknown Bullet subclass %r" %
                                      str(alias))
        # create designated subclass object (call its __init__ method)
        subclass = cls.registry[alias]
        return type.__call__(subclass, *args, **kwargs)

class Bullet(object):
    __metaclass__ = BulletMeta
    # Presumably you'd define some abstract methods that all here
    # that would be supported by all subclasses.
    # These definitions could just raise NotImplementedError() or
    # implement the functionality is some sub-optimal generic way.
    # For example:
    def fire(self, *args, **kwargs):
        raise NotImplementedError(self.__class__.__name__ + ".fire() method")

    # abstract base class's __init__ should never be called
    # (if subclasses need to call super class's __init__(),
    # then then it might be implemented)
    def __init__(self, *args, **kwargs):
        raise NotImplementedError("Bullet is an abstract base class")

# subclass definitions
class Bullet1(Bullet):
    alias = 'B1'
    def __init__(self, sprite, start, direction, speed):
        print 'creating %s object' % self.__class__.__name__
    def fire(self, trajectory):
        print 'Bullet1 object fired with %s trajectory' % trajectory

class Bullet2(Bullet):
    alias = 'B2'
    def __init__(self, sprite, start, headto, spead, acceleration):
        print 'creating %s object' % self.__class__.__name__

class Bullet3(Bullet):
    alias = 'B3'
    def __init__(self, sprite, script): # script controlled bullets
        print 'creating %s object' % self.__class__.__name__

class Bullet4(Bullet):
    alias = 'B4'
    def __init__(self, sprite, curve, speed): # for bullets with curved paths
        print 'creating %s object' % self.__class__.__name__

class Sprite: pass
class Curve: pass

b1 = Bullet('B1', Sprite(), (10,20,30), 90, 600)             # creating Bullet1 object
b2 = Bullet('B2', Sprite(), (-30,17,94), (1,-1,-1), 600, 10) # creating Bullet2 object
b3 = Bullet('B3', Sprite(), 'bullet42.script')               # creating Bullet3 object
b4 = Bullet('B4', Sprite(), Curve(), 720)                    # creating Bullet4 object
b1.fire('uniform gravity') # Bullet1 object fired with uniform gravity trajectory
b2.fire('uniform gravity') # NotImplementedError: Bullet2.fire() method
	
edited Feb 19 '14 at 1:35
	
answered Jun 22 '11 at 15:00
martineau
34.8k64683
	
==============

http://stackoverflow.com/questions/16564198/pythons-equivalent-of-nets-sealed-class
geen sealed class; je kan afleiding voorkomen met metaclass:

class Final(type):
    def __new__(cls, name, bases, classdict):
        for b in bases:
            if isinstance(b, Final):
                raise TypeError("type '{0}' is not an acceptable base type".format(b.__name__))
        return type.__new__(cls, name, bases, dict(classdict))

class Foo:
    __metaclass__ = Final

class Bar(Foo):
    pass

==============

http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Metaprogramming.html
heel veel info over metaprogramming

==============

http://www.nltk.org/book/

Natural Language Processing with Python

– Analyzing Text with the Natural Language Toolkit
Steven Bird, Ewan Klein, and Edward Loper 
This version of the NLTK book is updated for Python 3 and NLTK 3. The first edition of the book, published by O'Reilly, is available at http://nltk.org/book_1ed/. (There are currently no plans for a second edition of the book.) 

https://www.youtube.com/watch?v=FLZvOKSCkxY
Natural Language Processing With Python and NLTK p.1 Tokenizing words and Sentences

---------

https://elitedatascience.com/python-nlp-libraries

5 Heroic Python NLP Libraries
October 29, 2016

•We recommend NLTK only as an education and research tool. Its modularized structure makes it excellent for learning and exploring NLP concepts, but it's not meant for production.
•TextBlob is built on top of NLTK, and it's more easily-accessible. This is our favorite library for fast-prototyping or building applications that don't require highly optimized performance. Beginners should start here.
•Stanford's CoreNLP is a Java library with Python wrappers. It's in many existing production systems due to its speed.
•SpaCy is a new NLP library that's designed to be fast, streamlined, and production-ready. It's not as widely adopted, but if you're building a new application, you should give it a try.

•Gensim is most commonly used for topic modeling and similarity detection. It's not a general-purpose NLP library, but for the tasks it does handle, it does them well.
Gensim is a well-optimized library for topic modeling and document similarity analysis.
Even so, it's a valuable tool to add to your repertoire. Its topic modeling algorithms, such as its Latent Dirichlet Allocation (LDA) implementation, are best-in-class. In addition, it's robust, efficient, and scalable.

Plus, the sub-field semantics analysis (or topic modeling), is one of the most exciting areas of modern natural language processing.
https://radimrehurek.com/gensim/

-----------

https://en.wikipedia.org/wiki/Latent_semantic_analysis

https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors

https://www.youtube.com/watch?v=BJ0MnawUpaU
Text Analytics - Latent Semantic Analysis
Mike Bernico
Published on Feb 1, 2015

https://www.youtube.com/watch?v=hXNbFNCgPfY
Using TF-IDF to convert unstructured text to useful features
Mike Bernico
Published on Feb 1, 2015

https://www.youtube.com/watch?v=BuMu-bdoVrU
PyTexas
Published on Oct 15, 2015
Topic models are a suite of algorithms that uncover the hidden thematic structure in document collections. These algorithms help us develop new ways to search, browse and summarize large archives of texts. This talk will introduce topic modeling and one of it's most widely used algorithms called LDA (Latent Dirichlet Allocation). Attendees will learn how to use Python to analyze the content of their text documents. The talk will go through the full topic modeling pipeline: from different ways of tokenizing your document, to using the Python library gensim, to visualizing your results and understanding how to evaluate them.

--------------

https://www.dataquest.io/blog/natural-language-processing-with-python/

Natural Language Processing with Python Tutorial
Vik Paruchuri 09 Jun 2015 in tutorials
[ecr: vb in python zelf, dus niet het Bird/Klein/Loper bk, ziet er goed uit]

--------------

https://www.youtube.com/watch?v=8QZWx_XAO1w
SEM101 - Semantics - An Overview
The Virtual Linguistics Campus
Jürgen Handtke
Published on Mar 11, 2013
This first E-Lecture related to the VLC class "Semantics and Pragmatics" provides an overview of the role of semantics within linguistics and its use in other disciplines. Furthermore, it discusses the central goals and objectives of semantics.
[ecr: erg basis]

https://www.youtube.com/watch?v=_NtVeofqUKA
SEM113 - Reference 
The Virtual Linguistics Campus
Jürgen Handtke
Published on Mar 13, 2013
What is the relation between a word and an object and how can we define this relationship? This superficially trival questions stands in the centerof this E-Lecture where J. Handke discusses types of reference, the notion of concepts and briefly looks at prototype theory.
[ecr: interessanter; vanaf 9:30 Frege, daarna Semiotic Triangle Ogden/Richards]

https://www.youtube.com/watch?v=ONV38l39PsE
SEM114 - Theories of Word Meaning

==============

http://users.rcn.com/python/download/Descriptor.htm
[ecr: geschreven voor 2.X]

How-To Guide for Descriptors

Author:  Raymond Hettinger 
Contact:  <python at rcn dot com> 
Copyright:  Copyright (c) 2003, 2004 Python Software Foundation. All rights reserved. 

Contents
•Abstract
•Definition and Introduction
•Descriptor Protocol
•Invoking Descriptors
•Descriptor Example
•Properties
•Functions and Methods
•Static Methods and Class Methods


Abstract

Defines descriptors, summarizes the protocol, and shows how descriptors are called. Examines a custom descriptor and several built-in python descriptors including functions, properties, static methods, and class methods. Shows how each works by giving a pure Python equivalent and a sample application.

Learning about descriptors not only provides access to a larger toolset, it creates a deeper understanding of how Python works and an appreciation for the elegance of its design.


Definition and Introduction

In general, a descriptor is an object attribute with "binding behavior", one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are __get__, __set__, and __delete__. If any of those methods are defined for an object, it is said to be a descriptor.

The default behavior for attribute access is to get, set, or delete the attribute from an object's dictionary. For instance, a.x has a lookup chain starting with a.__dict__['x'], then type(a).__dict__['x'], and continuing through the base classes of type(a) excluding metaclasses. If the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined. Note that descriptors are only invoked for new style objects or classes (a class is new style if it inherits from object or type).

Descriptors are a powerful, general purpose protocol. They are the mechanism behind properties, methods, static methods, class methods, and super(). They are used used throughout Python itself to implement the new style classes introduced in version 2.2. Descriptors simplify the underlying C-code and offer a flexible set of new tools for everyday Python programs.


Descriptor Protocol

descr.__get__(self, obj, type=None) --> value

descr.__set__(self, obj, value) --> None

descr.__delete__(self, obj) --> None

That is all there is to it. Define any of these methods and an object is considered a descriptor and can override default behavior upon being looked up as an attribute.

If an object defines both __get__ and __set__, it is considered a data descriptor. Descriptors that only define __get__ are called non-data descriptors (they are typically used for methods but other uses are possible).

Data and non-data descriptors differ in how overrides are calculated with respect to entries in an instance's dictionary. If an instance's dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance's dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.

To make a read-only data descriptor, define both __get__ and __set__ with the __set__ raising an AttributeError when called. Defining the __set__ method with an exception raising placeholder is enough to make it a data descriptor.


Invoking Descriptors

A descriptor can be called directly by its method name. For example, d.__get__(obj).

Alternatively, it is more common for a descriptor to be invoked automatically upon attribute access. For example, obj.d looks up d in the dictionary of obj. If d defines the method __get__, then d.__get__(obj) is invoked according to the precedence rules listed below.

The details of invocation depend on whether obj is an object or a class. Either way, descriptors only work for new style objects and classes. A class is new style if it is a subclass of object.

For objects, the machinery is in object.__getattribute__ which transforms b.x into type(b).__dict__['x'].__get__(b, type(b)). The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to __getattr__ if provided. The full C implementation can be found in PyObject_GenericGetAttr() in Objects/object.c.

For classes, the machinery is in type.__getattribute__ which transforms B.x into B.__dict__['x'].__get__(None, B). In pure Python, it looks like:
def __getattribute__(self, key):
    "Emulate type_getattro() in Objects/typeobject.c"
    v = object.__getattribute__(self, key)
    if hasattr(v, '__get__'):
       return v.__get__(None, self)
    return v

The important points to remember are:
•descriptors are invoked by the __getattribute__ method
•overriding __getattribute__ prevents automatic descriptor calls
•__getattribute__ is only available with new style classes and objects
•object.__getattribute__ and type.__getattribute__ make different calls to __get__.
•data descriptors always override instance dictionaries.
•non-data descriptors may be overridden by instance dictionaries.

The object returned by super() also has a custom __getattribute__ method for invoking descriptors. The call super(B, obj).m() searches obj.__class__.__mro__ for the base class A immediately following B and then returns A.__dict__['m'].__get__(obj, A). If not a descriptor, m is returned unchanged. If not in the dictionary, m reverts to a search using object.__getattribute__.

Note, in Python 2.2, super(B, obj).m() would only invoke __get__ if m was a data descriptor. In Python 2.3, non-data descriptors also get invoked unless an old-style class is involved. The implementation details are in super_getattro() in Objects/typeobject.c and a pure Python equivalent can be found in Guido's Tutorial.

The details above show that the mechanism for descriptors is embedded in the __getattribute__() methods for object, type, and super. Classes inherit this machinery when they derive from object or if they have a meta-class providing similar functionality. Likewise, classes can turn-off descriptor invocation by overriding __getattribute__().


Descriptor Example

The following code creates a class whose objects are data descriptors which print a message for each get or set. Overriding __getattribute__ is alternate approach that could do this for every attribute. However, this descriptor is useful for monitoring just a few chosen attributes:
class RevealAccess(object):
    """A data descriptor that sets and returns values
       normally and prints a message logging their access.
    """

    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print 'Retrieving', self.name
        return self.val

    def __set__(self, obj, val):
        print 'Updating' , self.name
        self.val = val

>>> class MyClass(object):
    x = RevealAccess(10, 'var "x"')
    y = 5

>>> m = MyClass()
>>> m.x
Retrieving var "x"
10
>>> m.x = 20
Updating var "x"
>>> m.x
Retrieving var "x"
20
>>> m.y
5

The protocol is simple and offers exciting possibilities. Several use cases are so common that they have been packaged into individual function calls. Properties, bound and unbound methods, static methods, and class methods are all based on the descriptor protocol.


Properties

Calling property() is a succinct way of building a data descriptor that triggers function calls upon access to an attribute. Its signature is:
property(fget=None, fset=None, fdel=None, doc=None) -> property attribute

The documentation shows a typical use to define a managed attribute x:
class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, "I'm the 'x' property.")

To see how property() is implemented in terms of the descriptor protocol, here is a pure Python equivalent:
class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self         
        if self.fget is None:
            raise AttributeError, "unreadable attribute"
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError, "can't set attribute"
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError, "can't delete attribute"
        self.fdel(obj)

The property() builtin helps whenever a user interface has granted attribute access and then subsequent changes require the intervention of a method.

For instance, a spreadsheet class may grant access to a cell value through Cell('b10').value. Subsequent improvements to the program require the cell to be recalculated on every access; however, the programmer does not want to affect existing client code accessing the attribute directly. The solution is to wrap access to the value attribute in a property() data descriptor:
class Cell(object):
    . . .
    def getvalue(self, obj):
        "Recalculate cell before returning value"
        self.recalc()
        return obj._value
    value = property(getvalue)


Functions and Methods

Python's object oriented features are built upon a function based environment. Using non-data descriptors, the two are merged seamlessly.

Class dictionaries store methods as functions. In a class definition, methods are written using def and lambda, the usual tools for creating functions. The only difference from regular functions is that the first argument is reserved for the object instance. By Python convention, the instance reference is called self but may be called this or any other variable name.

To support method calls, functions include the __get__ method for binding methods during attribute access. This means that all functions are non-data descriptors which return bound or unbound methods depending whether they are invoked from an object or a class. In pure python, it works like this:
class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        return types.MethodType(self, obj, objtype)

Running the interpreter shows how the function descriptor works in practice:
>>> class D(object):
     def f(self, x):
          return x

>>> d = D()
>>> D.__dict__['f'] # Stored internally as a function
<function f at 0x00C45070>
>>> D.f             # Get from a class becomes an unbound method
<unbound method D.f>
>>> d.f             # Get from an instance becomes a bound method
<bound method D.f of <__main__.D object at 0x00B18C90>>

The output suggests that bound and unbound methods are two different types. While they could have been implemented that way, the actual C implemention of PyMethod_Type in Objects/classobject.c is a single object with two different representations depending on whether the im_self field is set or is NULL (the C equivalent of None).

Likewise, the effects of calling a method object depend on the im_self field. If set (meaning bound), the original function (stored in the im_func field) is called as expected with the first argument set to the instance. If unbound, all of the arguments are passed unchanged to the original function. The actual C implementation of instancemethod_call() is only slightly more complex in that it includes some type checking.


Static Methods and Class Methods

Non-data descriptors provide a simple mechanism for variations on the usual patterns of binding functions into methods.

To recap, functions have a __get__ method so that they can be converted to a method when accessed as attributes. The non-data descriptor transforms a obj.f(*args) call into f(obj, *args). Calling klass.f(*args) becomes f(*args).

This chart summarizes the binding and its two most useful variants:

Transformation

Called from an Object
Called from a Class

Descriptor function f(obj, *args) f(*args) 
staticmethod f(*args) f(*args) 
classmethod f(type(obj), *args) f(klass, *args) 

Static methods return the underlying function without changes. Calling either c.f or C.f is the equivalent of a direct lookup into object.__getattribute__(c, "f") or object.__getattribute__(C, "f"). As a result, the function becomes identically accessible from either an object or a class.

Good candidates for static methods are methods that do not reference the self variable.

For instance, a statistics package may include a container class for experimental data. The class provides normal methods for computing the average, mean, median, and other descriptive statistics that depend on the data. However, there may be useful functions which are conceptually related but do not depend on the data. For instance, erf(x) is handy conversion routine that comes up in statistical work but does not directly depend on a particular data set. It can be called either from an object or the class: s.erf(1.5) --> .9332 or Sample.erf(1.5) --> .9332.

Since staticmethods return the underlying function with no changes, the example calls are unexciting:
>>> class E(object):
     def f(x):
          print x
     f = staticmethod(f)

>>> print E.f(3)
3
>>> print E().f(3)
3

Using the non-data descriptor protocol, a pure Python version of staticmethod() would look like this:
class StaticMethod(object):
 "Emulate PyStaticMethod_Type() in Objects/funcobject.c"

 def __init__(self, f):
      self.f = f

 def __get__(self, obj, objtype=None):
      return self.f

Unlike static methods, class methods prepend the class reference to the argument list before calling the function. This format is the same for whether the caller is an object or a class:
>>> class E(object):
     def f(klass, x):
          return klass.__name__, x
     f = classmethod(f)

>>> print E.f(3)
('E', 3)
>>> print E().f(3)
('E', 3)

This behavior is useful whenever the function only needs to have a class reference and does not care about any underlying data. One use for classmethods is to create alternate class constructors. In Python 2.3, the classmethod dict.fromkeys() creates a new dictionary from a list of keys. The pure Python equivalent is:
class Dict:
    . . .
    def fromkeys(klass, iterable, value=None):
        "Emulate dict_fromkeys() in Objects/dictobject.c"
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)

Now a new dictionary of unique keys can be constructed like this:
>>> Dict.fromkeys('abracadabra')
{'a': None, 'r': None, 'b': None, 'c': None, 'd': None}

Using the non-data descriptor protocol, a pure Python version of classmethod() would look like this:
class ClassMethod(object):
     "Emulate PyClassMethod_Type() in Objects/funcobject.c"

     def __init__(self, f):
          self.f = f

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def newfunc(*args):
               return self.f(klass, *args)
          return newfunc

================

http://www.informit.com/articles/printerfriendly/1309289

InformIT  
Python Descriptors 

By Mark Summerfield

Date: Dec 15, 2008

Return to the article

Mark Summerfield shows how to use Python descriptors for powerful attribute control, including how to create attribute-validating class decorators by using new Python 2.6/3.0 features. 

Python descriptors have been around a long time—they were introduced way back in Python 2.2. But they're still not widely understood or used. This article shows how to create descriptors and presents three examples of use. All three examples run under Python 3.0, although the first two can be back-ported to any Python version from 2.2 onward simply by changing each class definition to inherit object, and by replacing uses of str.format() with the % string formatting operator. The third example is more advanced, combining descriptors with class decorators—the latter introduced with Python 2.6 and 3.0—to produce a uniquely powerful effect.

What Are Descriptors?

A descriptor is a class that implements one or more of the special methods, __get__(), __set__(), and __delete__(). Descriptor instances are used to represent the attributes of other classes. For example, if we had a descriptor class called MyDescriptor, we might define a class that used it like this:
class MyClass:
    a = MyDescriptor("a")
    b = MyDescriptor("b")

(In Python 2.x versions, we would write class MyClass(object): to make the class a new-style class.) The MyClass class now has two instance variables, accessible as self.a and self.b in MyClass objects. How these instance variables behave depends entirely on the implementation of the MyDescriptor class—and this is what makes descriptors so versatile and powerful. In fact, Python itself uses descriptors to implement properties and static methods.

Now we'll look at three examples that use descriptors for three completely different purposes so that you can start to see what can be achieved with descriptors. The first two examples show read-only attributes; the third example shows editable attributes. None of the examples covers deletable attributes (using __delete__()), since use cases are rather rare.

Using Descriptors to Compute Attributes

We often create classes holding data items that we want to access in more than one form. For example, imagine that we have a Person class that holds a person's salutation, forename, and surname. Typically we want to display the complete name in some standard form; for example, the salutation, the first initial of the forename, a period, and then the surname. We could easily do this by creating an additional "display name" instance variable whenever a new Person object was created. But this approach has some disadvantages:
•We must store an extra string for every person, even if we rarely use it.
•If the salutation, forename, or surname is changed, we must update the display name.

It would be much better if we could just create the display name when it was needed—this technique would avoid the need to store or update an extra string for each person. Here's how the definition of such a Person class might look:
class Person:

    display_name = DisplayName()

    def __init__(self, salutation, forename, surname):
        self.salutation = salutation
        self.forename = forename
        self.surname = surname

Every instance of the Person class has four instance attributes:
•self.salutation
•self.forename
•self.surname
•self.display_name

The self.display_name attribute is represented by an instance of the DisplayName descriptor class (so it doesn't use any memory for each Person instance), yet it's accessed like any other attribute. (In this case, we've made it read-only; as you'll see shortly, the descriptor has a getter but no setter.)

For example:
fred = Person("", "Fred", "Bloggs")
assert fred.display_name == "F. Bloggs"
jane = Person("Ms", "Jane", "Doe")
assert jane.display_name == "Ms J. Doe"

The implementation of the descriptor class is very simple:
class DisplayName:

    def __get__(self, instance, owner=None):
        parts = []
        if instance.salutation:
            parts.append(instance.salutation)
        if instance.forename:
            parts.append(instance.forename[0] + ".")
        parts.append(instance.surname)
        return " ".join(parts)

When an attribute is read via a descriptor, the descriptor's __get__() method is called. The self argument is the descriptor instance, the instance argument is the instance of the object for whose class the descriptor is defined, and the owner argument is that class. So, when fred.display_name is used, the Person class' instance of the DisplayName descriptor's __get__() method is called with Person.displayName as the self argument, fred as the instance argument, and Person as the owner argument.

Of course, the same goal could be achieved by using a display name property. By using a descriptor, however, we can create as many display name attributes as we like, in as many different classes as we like—all getting their behavior from the descriptor with a single line of code for each one. This design eases maintenance; if we need to change how the display name attribute works (perhaps to change the format of the string it returns), we have to change the code in only one place—in the descriptor—rather than in individual property functions for each relevant attribute in every affected class.

Clearly, descriptors can be useful for reducing the memory footprint of classes in which attributes can be computed. This footprint can be reduced still further by using slots; for example, by adding this line to the Person class:
__slots__ = ("salutation", "forename", "surname")

If the computation is expensive, we could cache the results in the descriptor, using the technique shown in the next section.

Using Descriptors to Store Data

Let's look at a use of descriptors that in some ways is the complete opposite of what we've just seen. In some situations, we may prefer to store all or some of a class' data outside the class, while at the same time being able to access the data through instance attributes in the normal way.

For example, suppose we need to store large numbers of Book objects, each holding the details of a particular book. Imagine further that for some of the books we need to output the book's details as a bibliographic entry in the DocBook XML format, and that when such output is required once, it's very likely to be required again. One way of handling this situation is to use a descriptor to generate the XML—and to cache what it generates.

Here's a class that uses such a descriptor:
class Book:

    biblioentry = BiblioEntry()

    def __init__(self, isbn, title, forename, surname, year):
        self.isbn = isbn
        self.title = title
        self.forename = forename
        self.surname = surname
        self.year = year

No biblioentry data is held in Book instances. When the data is requested (for example, book.biblioentry) for the first time, the entry is computed; on the second and subsequent requests, the computed entry is returned immediately. Here's the descriptor's definition:
class BiblioEntry:

    def __init__(self):
        self.cache = {}

    def __get__(self, instance, owner=None):
        entry = self.cache.get(id(instance), None)
        if entry is not None:
            return entry
        entry = """<biblioentry><abbrev>{surname}{yr:02d}</abbrev>
<authorgroup><author><firstname>{forename}</firstname>
<surname>{surname}</surname></author></authorgroup>
<copyright><year>{year}</year></copyright>
<isbn>{isbn}</isbn><title>{title}</title>
</biblioentry>\n""".format(
        yr=(instance.year - 2000 if instance.year >= 2000
                                else instance.year - 1900),
        forename=xml.sax.saxutils.escape(instance.forename),
        surname=xml.sax.saxutils.escape(instance.surname),
        title=xml.sax.saxutils.escape(instance.title),
        isbn=instance.isbn, year=instance.year)
        self.cache[id(instance)] = entry
        return entry


NOTE

In the str.format() method of Python 2.6 and 3.0, each item inside the string that's enclosed in braces represents a variable to be substituted. The first part is either the index of the argument given to the method, or its name if keyword values are used. Here we've used keywords. If formatting is required, it's specified after a colon; in this case, we've asked for the abbreviated year to be shown as two digits with zero padding—{yr:02d}.

Structurally, the code is quite similar to the previous example, but here we create a cache whose keys are unique instance IDs and whose values are XML biblioentry strings, suitably escaped. By using the cache we ensure that the expensive computation is done only once for each book for which it's needed. We chose to store IDs rather than the instances themselves, to avoid forcing the Book instances to be hashable.

By caching, we're trading memory for speed; whether that's the right tradeoff can only be determined on a case-by-case basis. Another issue to note: When using caching, if the data changes, some or all of the cache's contents become invalid. Since the details of published books don't change, it isn't a problem in this example, but if changes were common we must cope with them. One approach is to use a "dirty" flag and ignore the cache if instance.dirty is True; another approach is to access the cache itself and clear it.

You can provide access to an attribute's underlying descriptor by adding two lines at the beginning of the descriptor's __get__() method:
def __get__(self, instance, owner=None):
    if instance is None:
        return self
    # ...

If we had the above lines at the start of the BiblioEntry's __get__() method, we could clear the cache like this:
Book.biblioentry.cache.clear()

Now that we've seen how we can provide both computed and stored attributes using descriptors, let's look at a third use of descriptors: validation.

Combining Descriptors with Class Decorators for Validation

Let's examine how to create attributes that are readable and writable and that are validated whenever they're set. We'll start by seeing an example of use, and then consider how to make the use possible:
@ValidString("name", empty_allowed=False)
@ValidNumber("price", minimum=0, maximum=1e6)
@ValidNumber("quantity", minimum=1, maximum=1000)
class StockItem:

    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

The StockItem class in this example has three attributes: self.name, self.price, and self.quantity. The first attribute must be a string and cannot be set to be empty. The second and third attributes must be numbers and can only be set to values in the ranges specified. For example:
cameras = StockItem("Camera", 45.99, 2)
cameras.quantity += 1 # works fine, quantity is now 3
cameras.quantity = -2 # raises ValueError("quantity -2 is too small")

The validation is achieved by combining class decorators with descriptors.

A class decorator takes a class definition as its sole argument and returns a new class with the same name as the one it was passed. This feature allows us to take a class, process it in some way, and produce a modified version of the class. And just as with function and method decorators, we can apply as many class decorators as we like, each one modifying the class further to produce the class we want.

In the code shown above, it looks like we've used a class decorator that takes multiple arguments, but that's not the case. The ValidString() and ValidNumber() functions take various arguments, and both return a class decorator; the decorator they return is used to decorate the class. Let's look at the ValidString() function, since it's the shorter and simpler of the two:
def ValidString(attr_name, empty_allowed=True):
    def decorator(cls):
        name = "__" + attr_name
        def getter(self):
            return getattr(self, name)
        def setter(self, value):
            assert isinstance(value, str), (attr_name +
                                            " must be a string")
            if not empty_allowed and not value:
                raise ValueError(attr_name +
                                " may not be empty")
            setattr(self, name, value)
        setattr(cls, attr_name, GenericDescriptor(getter, setter))
        return cls
    return decorator

The function takes two arguments—the name of the attribute to validate, and one validation criterion (in this case, whether the attribute can be empty). Inside the function we create a decorator function. The decorator takes a class as argument and will create a private data attribute based on the attribute name. For example, the "name" attribute used in the example will have its data held in self.__name.

Next, a getter function is created that uses Python's getattr() function to return the attribute with the given name. Then a setter function is created, and here the validation code is written and the setattr() function is used to set the new value. After defining the getter and setter, setattr() is called on the class to create a new attribute with the given name (for instance, self.name), and this attribute's value is set to be a descriptor of type GenericDescriptor. Finally, the decorator function returns the modified class, and the ValidString() function returns the decorator function.

The class decorated with one or more uses of ValidString() will have two new attributes added for each use. For example, if the name given is "name", the attributes will be self.__name (which will hold the actual data) and self.name (a descriptor through which the data can be accessed).

Now that we've seen how the decorator is created, we're ready to see the—remarkably simple—descriptor:
class GenericDescriptor:

    def __init__(self, getter, setter):
        self.getter = getter
        self.setter = setter

    def __get__(self, instance, owner=None):
        if instance is None:
            return self
        return self.getter(instance)

    def __set__(self, instance, value):
        return self.setter(instance, value)

The GenericDescriptor takes a getter and a setter function and uses them to get and set the attribute data in the given instance. This means that the data is held in the instance, not in the descriptor—the descriptor purely provides the means of accessing the data by using its getter and setter functions.

The ValidNumber() function is almost identical to the ValidString() function, the only differences being the arguments it takes (specifying the minimum and maximum acceptable values), and the setter it creates. Here's an extract that just shows the setter:
def setter(self, value):
    assert isinstance(value, numbers.Number), (
            attr_name + " must be a number")
    if minimum is not None and value < minimum:
            raise ValueError("{0} {1} is too small".format(
                                attr_name, value))
    if maximum is not None and value > maximum:
            raise ValueError("{0} {1} is too big".format(
                                attr_name, value))
    setattr(self, name, value)

The numbers.Number abstract base class is used to identify any kind of number.

The decorator/descriptor pattern shown here can be used to create validation functions for any type of data.

Conclusion

Descriptors are a powerful and useful Python feature, especially when combined with class decorators. Although decorators are declared as class attributes, they're accessed as instance attributes; if we want to associate data with a descriptor, we must either compute that data when it's requested (as in the first example), or provide storage for it (for example, using a cache, as in the second example). If we want to store descriptor-related data in instances, we can do so by using a class decorator to create a data attribute to hold the data and a descriptor attribute to provide mediated access to the data, as the third example showed.

Like most of Python's advanced features, descriptors and class decorators are not the first tools to try when a problem needs to be solved. But they should always be kept in mind because, in the right circumstances, they can provide clean and elegant solutions that aren't easily achieved by other means.

For details on the techniques shown in this article (along with many other Python techniques), see my book Programming in Python 3: A Complete Introduction to the Python Language.



© 2017 Pearson Education, Informit. All rights reserved.

800 East 96th Street, Indianapolis, Indiana 46240

==============

https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/
Python 201: What are descriptors?

https://stackoverflow.com/questions/371753/how-to-implement-getattribute-without-an-infinite-recursion-error
vooral antw interessant

==============

https://www.ibm.com/developerworks/linux/library/l-cpdecor/index.html

Charming Python

Decorators make magic easy


David Mertz
Published on December 29, 2006

Doing a lot by doing very little

Decorators have something in common with previous metaprogramming abstractions introduced to Python: they do not actually do anything you could not do without them. As Michele Simionato and I pointed out in earlier Charming Python installments, it was possible even in Python 1.5 to manipulate Python class creation without the "metaclass" hook. 

Decorators are similar in their ultimate banality. All a decorator does is modify the function or method that is defined immediately after the decorator. This was always possible, but the capability was particularly motivated by the introduction of the classmethod() and staticmethod() built-in functions in Python 2.2. In the older style, you would use a classmethod() call, for example, as follows: 

Listing 1. Typical "old style" classmethod
 
class C:
    def foo(cls, y):
        print "classmethod", cls, y
    foo = classmethod(foo)
 

Though classmethod() is a built-in, there is nothing unique about it; you could also have "rolled your own" method transforming function. For example: 

Listing 2. Typical "old style" method transform

def enhanced(meth):
    def new(self, y):
        print "I am enhanced"
        return meth(self, y)
    return new
class C:
    def bar(self, x):
        print "some method says:", x
    bar = enhanced(bar)
 

All a decorator does is let you avoid repeating the method name, and put the decorator near the first mention of the method in its definition. For example: 

Listing 3. Typical "old style" classmethod
 
class C:
    @classmethod
    def foo(cls, y):
        print "classmethod", cls, y
    @enhanced
    def bar(self, x):
        print "some method says:", x

Decorators work for regular functions too, in the same manner as for methods in classes. It is surprising just how much easier such a simple, and strictly-speaking unnecessary, change in syntax winds up making things work better, and makes reasoning about programs easier. Decorators can be chained together by listing more than one prior to a function of method definition; good sense urges avoiding chaining too many decorators together, but several are sometimes sensible: 

Listing 4. Chained decorators
 
@synchronized
@logging
def myfunc(arg1, arg2, ...):
    # ...do something
# decorators are equivalent to ending with:
#    myfunc = synchronized(logging(myfunc))
# Nested in that declaration order

Being simply syntax sugar, decorators let you shoot yourself in the foot if you are so inclined. A decorator is just a function that takes at least one argument -- it is up to the programmer of the decorator to make sure that what it returns is still a meaningful function or method that does enough of what the original function did for the connection to be useful. For example, a couple of syntactic misuses are: 

Listing 5. Bad decorator that does not even return function

>>> def spamdef(fn):
...     print "spam, spam, spam"
...
>>> @spamdef
... def useful(a, b):
...     print a**2 + b**2
...
spam, spam, spam
>>> useful(3, 4)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: 'NoneType' object is not callable

A decorator might return a function, but one that is not meaningfully associated with the undecorated function: 

Listing 6. Decorator whose function ignores passed-in function

>>> def spamrun(fn):
...     def sayspam(*args):
...         print "spam, spam, spam"
...     return sayspam
...
>>> @spamrun
... def useful(a, b):
...     print a**2 + b**2
...
>>> useful(3,4)
spam, spam, spam

Finally, a better behaved decorator will in some way enhance or modify the action of the undecorated function: 

Listing 7. Decorator that modifies behavior of undecorated func

>>> def addspam(fn):
...     def new(*args):
...         print "spam, spam, spam"
...         return fn(*args)
...     return new
...
>>> @addspam
... def useful(a, b):
...     print a**2 + b**2
...
>>> useful(3,4)
spam, spam, spam
25

You might quibble over just how useful useful() is, or whether addspam() is really such a good enhancement, but at least the mechanisms follow the pattern you will typically see in useful decorators. 

Introduction to high-level abstraction

Most of what metaclasses are used for, in my experience, is modifying the methods contained in a class once it is instantiated. Decorators do not currently let you modify class instantiation per se, but they can massage the methods that are attached to the class. This does not let you add or remove methods or class attributes dynamically during instantiation, but it does let the methods change their behavior depending on conditions in the environment at runtime. Now technically, a decorator applies when a class statement is run, which for top-level classes is closer to "compile time" than to "runtime." But arranging runtime determination of decorators is as simple as creating a class factory. For example: 

Listing 8. Robust, but deeply nested, decorator

def arg_sayer(what):
    def what_sayer(meth):
        def new(self, *args, **kws):
            print what
            return meth(self, *args, **kws)
        return new
    return what_sayer
 
def FooMaker(word):
    class Foo(object):
        @arg_sayer(word)
        def say(self): pass
    return Foo()
 
foo1 = FooMaker('this')
foo2 = FooMaker('that')
print type(foo1),; foo1.say()  # prints: <class '__main__.Foo'> this
print type(foo2),; foo2.say()  # prints: <class '__main__.Foo'> that

The @arg_sayer() example goes through a lot of contortions to obtain a rather limited result, but it is worthwhile for the several things it illustrates: 
• The Foo.say() method has different behaviors for different instances. In the example, the difference only amounts to a data value that could easily be varied by other means; but in principle, the decorator could have completely rewritten the method based on runtime decisions. 
• The undecorated Foo.say() method in this case is a simple placeholder, with the entire behavior determined by the decorator. However, in other cases, the decorator might combine the undecorated method behavior with some new capabilities. 
• As already observed, the modification of Foo.say() is determined strictly at runtime, via the use of the FooMaker() class factory. Probably more typical is using decorators on top-level defined classes, which depend only on conditions available at compile-time (which are often adequate). 
• The decorator is parameterized. Or rather arg_sayer() itself is not really a decorator at all; rather, the function returned byarg_sayer(), namely what_sayer(), is a decorator function that uses a closure to encapsulate its data. Parameterized decorators are common, but they wind up needed functions nested three-levels deep. 

Marching into metaclass territory

As mentioned in the last section, decorators could not completely replace the metaclass hook since they only modify methods rather than add or delete methods. This is actually not quite true. A decorator, being a Python function, can do absolutely anything other Python code can. By decorating the .__new__() method of a class, even a placeholder version of it, you can, in fact, change what methods attach to a class. I have not seen this pattern "in the wild," but I think it has a certain explicitness, perhaps even as an improvement on the _metaclass_ assignment: 

Listing 9. A decorator to add and remove methods

def flaz(self): return 'flaz'     # Silly utility method
def flam(self): return 'flam'     # Another silly method
 
def change_methods(new):
    "Warning: Only decorate the __new__() method with this decorator"
    if new.__name__ != '__new__':
        return new  # Return an unchanged method
    def __new__(cls, *args, **kws):
        cls.flaz = flaz
        cls.flam = flam
        if hasattr(cls, 'say'): del cls.say
        return super(cls.__class__, cls).__new__(cls, *args, **kws)
    return __new__
 
class Foo(object):
    @change_methods
    def __new__(): pass
    def say(self): print "Hi me:", self
 
foo = Foo()
print foo.flaz()  # prints: flaz
foo.say()         # AttributeError: 'Foo' object has no attribute 'say'

In the sample change_methods() decorator, some fixed methods are added and removed, fairly pointlessly. A more realistic case would use some patterns from the previous section. For example, a parameterized decorator could accept a data structure indicating methods to be added or removed; or perhaps some feature of the environment like a database query could make this decision. This manipulation of attached methods could also be wrapped in a function factory as before, deferring the final decision until runtime. These latter techniques might even be more versatile than _metaclass_ assignment. For example, you might call an enhanced change_methods() like this: 

Listing 10. Enhanced change_methods()

class Foo(object):
    @change_methods(add=(foo, bar, baz), remove=(fliz, flam))
    def __new__(): pass

Changing a call model

The most typical examples you will see discussed for decorators can probably be described as making a function or method "do something extra" while it does its basic job. For example, on places like the Python Cookbook Web site (see Related topics for a link), you might see decorators to add capabilities like tracing, logging, memorization/caching, thread locking, and output redirection. Related to these modifications -- but in a slightly different spirit -- are "before" and "after" modifications. One interesting possibility for before/after decoration is checking types of arguments to a function and the return value from a function. Presumably such a type_check() decorator would raise an exception or take some corrective action if the types are not as expected. 

In somewhat the same vein as before/after decorators, I got to thinking about the "elementwise" application of functions that is characteristic of the R programming language, and of NumPy. In these languages, numeric functions generally apply to each element in a sequence of elements, but also to an individual number. 

Certainly the map() function, list-comprehensions, and more recently generator-comprehensions, let you do elementwise application. But these require minor workarounds to get R-like behavior: the type of sequence returned by map() is always a list; and the call will fail if you pass it a single element rather than a sequence. For example: 

Listing 11. map() call that will fail

>>> from math import sqrt
>>> map(sqrt, (4, 16, 25))
[2.0, 4.0, 5.0]
>>> map(sqrt, 144)
TypeError: argument 2 to map() must support iteration

It is not hard to create a decorator that "enhances" a regular numerical function: 

Listing 12. Converting a function to an elementwise function

def elementwise(fn):
    def newfn(arg):
        if hasattr(arg,'__getitem__'):  # is a Sequence
            return type(arg)(map(fn, arg))
        else:
            return fn(arg)
    return newfn
 
@elementwise
def compute(x):
    return x**3 - 1
 
print compute(5)        # prints: 124
print compute([1,2,3])  # prints: [0, 7, 26]
print compute((1,2,3))  # prints: (0, 7, 26)

It is not hard, of course, to simply write a compute() function that builds in the different return types; the decorator only takes a few lines, after all. But in what might be described as a nod to aspect-oriented programming, this example lets us separate concerns that operate at different levels. We might write a variety of numeric computation functions and wish to turn them each into elementwise call models without thinking about the details of argument type testing and return value type coercion. 

The elementwise() decorator works equally well for any function that might operate on either an individual thing or on a sequence of things (while preserving the sequence type). As an exercise, you might try working out how to allow the same decorated call to also accept and return iterators (hint: it is easy if you just iterate a completed elementwise computation, it is less straightforward to do lazily if and only if an iterator object is passed in). 

Most good decorators you will encounter employ much of this paradigm of combining orthogonal concerns. Traditional object-oriented programming, especially in languages like Python that allow multiple inheritance, attempt to modularize concerns with an inheritance hierarchy. However, merely getting some methods from one ancestor, and other methods from other ancestors requires a conception in which concerns are much more separated than they are in aspect-oriented thinking. Taking best advantage of generators involves thinking about issues somewhat differently than does mix-and-matching methods: each method might be made to work in different ways depending on concerns that are outside of the "heart" of the method itself. 

Decorating your decorators

Before I end this installment, I want to point you to a really wonderful Python module called decorator written by my sometimes co-author Michele Simionato. This module makes developing decorators much nicer. Having a certain reflexive elegance, the main component of the decorator module is a decorator called decorator(). A function decorated with @decorator can be written in a simpler manner than one without it (see Related topics for related reading).

Michele has produced quite good documentation of his module, so I will not attempt to reproduce it; but I would like to point out the basic problems it solves. There are two main benefits to the decorator module. On the one hand, it lets you write decorators with fewer levels of nesting than you would otherwise need ("flat is better than nested"); but more interesting possibly is the fact that it makes decorated functions actually match their undecorated version in metadata, which my examples have not. For example, recalling the somewhat silly "tracing" decorator addspam() that I used above: 

Listing 13. How a naive decorator corrupts metadata

>>> def useful(a, b): return a**2 + b**2
>>> useful.__name__
'useful'
>>> from inspect import getargspec
>>> getargspec(useful)
(['a', 'b'], None, None, None)
>>> @addspam
... def useful(a, b): return a**2 + b**2
>>> useful.__name__
'new'
>>> getargspec(useful)
([], 'args', None, None)

While the decorated function does its enhanced job, a closer look shows it is not quite right, especially to code-analysis tools or IDEs that care about these sorts of details. Using decorator, we can improve matters: 

Listing 14. Smarter use of decorator

>>> from decorator import decorator
>>> @decorator
... def addspam(f, *args, **kws):
...     print "spam, spam, spam"
...     return f(*args, **kws)
>>> @addspam
... def useful(a, b): return a**2 + b**2
>>> useful.__name__
'useful'
>>> getargspec(useful)
(['a', 'b'], None, None, None)

This looks better both to write the decorator in the first place, and in its behavior-preserving metadata. Of course, reading the full incantations that Michele used to develop the module brings you back into brain-melting territory; we can leave that for cosmologists like Dr. Simionato. 

===============

lxml

http://lxml.de/installation.html

For MS Windows, recent lxml releases feature community donated binary distributions, although you might still want to take a look at the related FAQ entry. If you fail to build lxml on your MS Windows system from the signed and tested sources that we release, consider using the binary builds from PyPI or the unofficial Windows binaries that Christoph Gohlke generously provides.

http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml

----------------

Download lxml-3.4.4-cp34-none-win_amd64.whl
run: C:\Python34\python.exe -m pip install lxml-3.4.4-cp34-none-win_amd64.whl
of: C:\Python34\Scripts\pip install ...

----------------

https://pypi.python.org/pypi/lxml/3.4.4

============

pillow

http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow

=============

http://www.lfd.uci.edu/~gohlke/pythonlibs/#vlfd

Unofficial Windows Binaries for Python Extension Packages

by Christoph Gohlke, Laboratory for Fluorescence Dynamics, University of California, Irvine.

This page provides 32- and 64-bit Windows binaries of many scientific open-source extension packages for the official CPython distribution of the Python programming language.

The files are unofficial (meaning: informal, unrecognized, personal, unsupported, no warranty, no liability, provided "as is") and made available for testing and evaluation purposes.

If downloads fail reload this page, enable JavaScript, disable download managers, disable proxies, clear cache, and use Firefox. Please only download files manually as needed.

Most binaries are built from source code found on PyPI or in the projects public revision control systems. Source code changes, if any, have been submitted to the project maintainers or are included in the packages.

Refer to the documentation of the individual packages for license restrictions and dependencies.

Use pip version 8 or newer to install the downloaded .whl files. This page is not a pip package index.

Many binaries depend on numpy-1.11+mkl and the Microsoft Visual C++ 2008 (x64, x86, and SP1 for CPython 2.7), Visual C++ 2010 (x64, x86, for CPython 3.4), or the Visual C++ 2015 (x64 and x86 for CPython 3.5 and 3.6) redistributable packages.

Install numpy+mkl before other packages that depend on it.

The binaries are compatible with the most recent official CPython distributions on Windows >=6.0. Chances are they do not work with custom Python distributions included with Blender, Maya, ArcGIS, OSGeo4W, ABAQUS, Cygwin, Pythonxy, Canopy, EPD, Anaconda, WinPython etc. Many binaries are not compatible with Windows XP or Wine.

The packages are ZIP or 7z files, which allows for manual or scripted installation or repackaging of the content.

The files are provided "as is" without warranty or support of any kind. The entire risk as to the quality and performance is with you.

The opinions or statements expressed on this page should not be taken as a position or endorsement of the Laboratory for Fluorescence Dynamics or the University of California.

============

https://www.airpair.com/python/posts/django-flask-pyramid

web frameworks
goed overzicht

=============

pywin32

toegang tot COM/ActiveX

http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32

PyWin32 provides extensions for Windows.
To install pywin32 system files, run from an admin command prompt:
>python.exe Scripts\pywin32_postinstall.py -install

ecr: installeren MOET via wheel, anders error. De postinstall moet je draaien om speciale dll's naar de system-dir te kopiëren + registry te vullen. Deze postinstall maakt tevens shortcuts.

uninstall met:
>python.exe Scripts\pywin32_postinstall.py -remove
draait fn uninstall(); deze doet:
	RegisterCOMObjects(False)
	RegisterPythonwin(False)

doet:
Unregistered: Python.Interpreter
Unregistered: Python.Dictionary
Unregistered: Python
Unregistered Pythonwin
Removed directory C:\Python34\Lib\site-packages\win32com\gen_py
Removed PythonWin.lnk
Removed Python for Windows Documentation.lnk
Removed file C:\windows\system32\pythoncom34.dll
Removed file C:\windows\system32\pywintypes34.dll


pypiwin32-221+dummy-py2.py3-none-any.whl
pywin32-221-cp27-cp27m-win32.whl
pywin32-221-cp27-cp27m-win_amd64.whl
pywin32-221-cp34-cp34m-win32.whl
pywin32-221-cp34-cp34m-win_amd64.whl
pywin32-221-cp35-cp35m-win32.whl
pywin32-221-cp35-cp35m-win_amd64.whl
pywin32-221-cp36-cp36m-win32.whl
pywin32-221-cp36-cp36m-win_amd64.whl

postinstall bij ncoi (->user install) geeft:

C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Scripts>..\python pywin32_postinstall.py -install

Copied pythoncom35.dll to C:\Windows\SysWOW64\pythoncom35.dll
Copied pywintypes35.dll to C:\Windows\SysWOW64\pywintypes35.dll
[ecr: vor bij install 32-bit Python op 64-bit win; op mijn 32-bit win7 NETBOOK ->..\System32]
Registered: Python.Interpreter
Registered: Python.Dictionary
Registered: Python
-> Software\Python\PythonCore\3.5\Help[None]=None
-> Software\Python\PythonCore\3.5\Help\Pythonwin Reference[None]='C:\\Users\\Cursist\\AppData\\Local\\Programs\\Python\\Python35-32\\Lib\\site-packages\\PyWin32.chm'
Pythonwin has been registered in context menu
Creating directory C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Lib\site-packages\win32com\gen_py
Shortcut for Pythonwin created
[ecr: C:\Python34\Lib\site-packages\pythonwin\Pythonwin.exe]
Shortcut to documentation created
[ecr: C:\Python34\Lib\site-packages\PyWin32.chm]
The pywin32 extensions were successfully installed.

in Lib\site-packages:
pythoncom.py
PyWin32.chm
pywin32.pth					[=path configuration file]
pywin32.version.txt			[=221]

adodbapi
pythonwin
pywin32_system32			[bevat pythoncom34.dll, pywintypes34.dll]
pywin32-221.dist-info
win32
win32com
win32comext

in Scripts:
pywin32_postinstall.py
pywin32_testall.py

in C:\Users\Ernesto\AppData\Local\Temp:
pywin32_postinstall.log

in registry:

pythonwin:
HKLM\SOFTWARE\Python\PythonCore\3.4
	\Help\Pythonwin Reference
	->Default = C:\Python34\Lib\site-packages\PyWin32.chm
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\Pythonwin.exe
	->Default = C:\Python34\Lib\site-packages\Pythonwin\Pythonwin.exe

pywin32, pywincom:
HKLM\SOFTWARE\Classes\Python
HKLM\SOFTWARE\Classes\Python.AXScript.2
	\CLSID ->Default = {DF630910-1C1D-11d0-AE36-8C0F5E000000}
HKLM\SOFTWARE\Classes\Python.Dictionary[.1]
	\CLSID ->Default = {39b61048-c755-11d0-86fa-00c04fc2e03e}
HKLM\SOFTWARE\Classes\Python.Interpreter[.2]
	\CLSID ->Default = {30BD3490-2632-11cf-AD5B-524153480001}

HKLM\SOFTWARE\Classes\CLSID
	\{DF630910-1C1D-11d0-AE36-8C0F5E000000} ->Default = Python ActiveX Scripting Engine
		\InprocServer32 ->Default = pythoncom34.dll
	\{39b61048-c755-11d0-86fa-00c04fc2e03e} ->Default = Python Dictionary
		\InprocServer32 ->Default = pythoncom34.dll
		\PythonCOM ->Default = win32com.servers.dictionary.DictionaryPolicy
		enz
	\{30BD3490-2632-11cf-AD5B-524153480001} ->Default = Python Interpreter
		\InprocServer32 ->Default = pythoncom34.dll
		\PythonCOM ->Default = win32com.servers.interp.Interpreter
		enz

-----------

timgolden.me.uk/pywin32-docs/contents.html
[ecr: zit ook in de bijgeleverde documentatie]

-----------

https://stackoverflow.com/questions/1065844/what-can-you-do-with-com-activex-in-python
First you have to install the wonderful pywin32 module.

It provides COM support. You need to run the makepy utility. It is located at C:...\Python26\Lib\site-packages\win32com\client. On Vista, it must be ran with admin rights.

This utility will show all available COM objects. You can find yours and it will generate a python wrapper for this object.

The wrapper is a python module generated in the C:...\Python26\Lib\site-packages\win32com\gen_py folder. The module contains the interface of the COM objects. The name of the file is the COM unique id. If you have many files, it is sometimes difficult to find the right one.

After that you just have to call the right interface. It is magical :)

ecr:
C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Lib\site-packages\win32com\client\makepy.py
->geeft win dlg Select Library, met lijst van Type libraries. Daar zie je bv Flappenbank (5.0).
selecteer de gewenste type lib en klik knop Ok.
->hij mkt wrapperfile met naam <CLSIS>.py, bv: E9DDAC18-F8C8-4886-8C55-F2B75F6DE0B9x0x5x0.py

[ecr: zie verder naar onderen:
To use the pywin32 module with an activex class you need to generate a wrapper file. To do this run makepy.py file in C:\Python27\Lib\site-packages\win32com\client (or your similar dir). In the Select Library window, locate the NAME of your activex class then run it.
It should generate a wrapper file in the gen_py folder C:\Python27\Lib\site-packages\win32com\gen_py with the CLSID in it. You can then access it like the excel example and the same way you would in other languages.

I had the same issue. I didn't know where to get that, which from what I can gather is the name of the CoClass (which I believe is the wrapper for the dll) created by the makepy program (maybe I'm wrong). After I read the answer by @NotAUser I found it, but when I inspected the file created by the makepy program, and right before the last class, (if more than one are created) I found the following:
from win32com.client import CoClassBaseClass
# This CoClass is known by the name 'ZKFPEngXControl.ZKFPEngX'
class ZKFPEngX(CoClassBaseClass): # A CoClass

So, there, in the same file there was the name I needed to use.
]

A short example with excel

import win32com.client

xlApp = win32com.client.Dispatch("Excel.Application")
xlApp.Visible=1

workBook = xlApp.Workbooks.Open(r"C:\MyTest.xls")
print str(workBook.ActiveSheet.Cells(i,1))
workBook.ActiveSheet.Cells(1, 1).Value = "hello"                
workBook.Close(SaveChanges=0) 
xlApp.Quit()

You can also find useful tips here : http://timgolden.me.uk/python/win32_how_do_i.html it's easy to adapt to any kind of application.

You can basically do the equivalent of late binding. So whatever is exposed through IDispatch is able to be consumed. 

Here's some code I wrote this weekend to get an image from a twain device via Windows Image Acquisition 2.0 and put the data into something I can shove in a gtk based UI.
WIA_COM = "WIA.CommonDialog"
WIA_DEVICE_UNSPECIFIED = 0
WIA_INTENT_UNSPECIFIED = 0
WIA_BIAS_MIN_SIZE = 65536
WIA_IMG_FORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"

def acquire_image_wia():
    wia = win32com.client.Dispatch(WIA_COM)
    img = wia.ShowAcquireImage(WIA_DEVICE_UNSPECIFIED,
                           WIA_INTENT_UNSPECIFIED,
                           WIA_BIAS_MIN_SIZE,
                           WIA_IMG_FORMAT_PNG,
                           False,
                           True)
    fname = str(time.time())
    img.SaveFile(fname)
    buff = gtk.gdk.pixbuf_new_from_file(fname)
    os.remove(fname)

return buff

It's not pretty but it works. I would assert it's equivalent to what you would have to write in VB.

https://stackoverflow.com/questions/11367925/how-can-i-use-activex-conrtols-through-python-to-control-a-texas-instruments-ddc

---------------

I have been tasked with figuring out how to use python to communicate with the DDC4100 digital controller. The DDC4100 is a component of the DLP Discovery 4100 Development kit. If you are curious about what that is you can click here.

I have been using PythonWin and the pywin32 packages to attempt to communicate with the controller.

I would like to use early binding automation so I used makepy to generate a wrapper for the DDC4100 ActiveX Control module.
# -*- coding: mbcs -*-
# Created by makepy.py version 0.5.01
# By python version 2.7.3 (default, Apr 10 2012, 23:31:26) [MSC v.1500 32 bit (Intel)]
# From type library 'DDC4100.tlb'
# On Fri Jul 06 10:52:42 2012
'DDC4100 ActiveX Control module'
makepy_version = '0.5.01'
python_version = 0x20703f0

import win32com.client.CLSIDToClass, pythoncom, pywintypes
import win32com.client.util
from pywintypes import IID
from win32com.client import Dispatch

# The following 3 lines may need tweaking for the particular server
# Candidates are pythoncom.Missing, .Empty and .ArgNotFound
defaultNamedOptArg=pythoncom.Empty
defaultNamedNotOptArg=pythoncom.Empty
defaultUnnamedArg=pythoncom.Empty

CLSID = IID('{4AB30830-EFC0-496D-8D38-ACFE2518ECEB}')
MajorVersion = 1
MinorVersion = 0
LibraryFlags = 10
LCID = 0x0

from win32com.client import DispatchBaseClass
class _DDDC4100(DispatchBaseClass):
    'Dispatch interface for DDC4100 Control'
    CLSID = IID('{C4374661-BB24-410F-9BEB-5DED735F4985}')
    coclass_clsid = IID('{5C75C113-9AFC-42AC-8CED-1ABFE27763B5}')

    def AboutBox(self):
        return self._oleobj_.InvokeTypes(-552, LCID, 1, (24, 0), (),)

 def AllowMessages(self, value=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(11, LCID, 1, (2, 0), ((2, 0),),value
            )

    def Clear(self, BlockNum=defaultNamedNotOptArg, DoReset=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(3, LCID, 1, (2, 0), ((2, 0), (2, 0)),BlockNum
            , DoReset)

    def ConnectDevice(self, DeviceNum=defaultNamedNotOptArg, SrcFile=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(14, LCID, 1, (2, 0), ((2, 0), (8, 0)),DeviceNum
            , SrcFile)

    def ConvertImage(self, SrcFile=defaultNamedNotOptArg, DestFile=defaultNamedNotOptArg, MirrorImage=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(4, LCID, 1, (2, 0), ((8, 0), (8, 0), (2, 0)),SrcFile
            , DestFile, MirrorImage)

    def DownloadAppsFPGACode(self, FileName=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(12, LCID, 1, (2, 0), ((8, 0),),FileName
            )

 def FileToFrameBuffer(self, ImageFile=defaultNamedNotOptArg, MirrorImage=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(6, LCID, 1, (2, 0), ((8, 0), (2, 0)),ImageFile
            , MirrorImage)
enz

I have been tasked with figuring out how to use python to communicate with the DDC4100 digital controller. The DDC4100 is a component of the DLP Discovery 4100 Development kit. If you are curious about what that is you can click here.

I have been using PythonWin and the pywin32 packages to attempt to communicate with the controller.

I would like to use early binding automation so I used makepy to generate a wrapper for the DDC4100 ActiveX Control module.
# -*- coding: mbcs -*-
# Created by makepy.py version 0.5.01
# By python version 2.7.3 (default, Apr 10 2012, 23:31:26) [MSC v.1500 32 bit (Intel)]
# From type library 'DDC4100.tlb'
# On Fri Jul 06 10:52:42 2012
'DDC4100 ActiveX Control module'
makepy_version = '0.5.01'
python_version = 0x20703f0

import win32com.client.CLSIDToClass, pythoncom, pywintypes
import win32com.client.util
from pywintypes import IID
from win32com.client import Dispatch

# The following 3 lines may need tweaking for the particular server
# Candidates are pythoncom.Missing, .Empty and .ArgNotFound
defaultNamedOptArg=pythoncom.Empty
defaultNamedNotOptArg=pythoncom.Empty
defaultUnnamedArg=pythoncom.Empty

CLSID = IID('{4AB30830-EFC0-496D-8D38-ACFE2518ECEB}')
MajorVersion = 1
MinorVersion = 0
LibraryFlags = 10
LCID = 0x0

from win32com.client import DispatchBaseClass
class _DDDC4100(DispatchBaseClass):
    'Dispatch interface for DDC4100 Control'
    CLSID = IID('{C4374661-BB24-410F-9BEB-5DED735F4985}')
    coclass_clsid = IID('{5C75C113-9AFC-42AC-8CED-1ABFE27763B5}')

    def AboutBox(self):
        return self._oleobj_.InvokeTypes(-552, LCID, 1, (24, 0), (),)

    def AllowMessages(self, value=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(11, LCID, 1, (2, 0), ((2, 0),),value
            )

    def Clear(self, BlockNum=defaultNamedNotOptArg, DoReset=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(3, LCID, 1, (2, 0), ((2, 0), (2, 0)),BlockNum
            , DoReset)

    def ConnectDevice(self, DeviceNum=defaultNamedNotOptArg, SrcFile=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(14, LCID, 1, (2, 0), ((2, 0), (8, 0)),DeviceNum
            , SrcFile)

    def ConvertImage(self, SrcFile=defaultNamedNotOptArg, DestFile=defaultNamedNotOptArg, MirrorImage=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(4, LCID, 1, (2, 0), ((8, 0), (8, 0), (2, 0)),SrcFile
            , DestFile, MirrorImage)

    def DownloadAppsFPGACode(self, FileName=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(12, LCID, 1, (2, 0), ((8, 0),),FileName
            )

    def FileToFrameBuffer(self, ImageFile=defaultNamedNotOptArg, MirrorImage=defaultNamedNotOptArg):
        return self._oleobj_.InvokeTypes(6, LCID, 1, (2, 0), ((8, 0), (2, 0)),ImageFile
            , MirrorImage)

    def FloatMirrors(self):
        return self._oleobj_.InvokeTypes(5, LCID, 1, (2, 0), (),)

    def GetActiveXRev(self):
        return self._oleobj_.InvokeTypes(13, LCID, 1, (3, 0), (),)


class _DDDC4100Events:
    'Event interface for DDC4100 Control'
    CLSID = CLSID_Sink = IID('{0CC72AA0-956F-48BD-9118-4446866ECBE3}')
    coclass_clsid = IID('{5C75C113-9AFC-42AC-8CED-1ABFE27763B5}')
    _public_methods_ = [] # For COM Server support
    _dispid_to_func_ = {
    }

    def __init__(self, oobj = None):
        if oobj is None:
            self._olecp = None
        else:
            import win32com.server.util
            from win32com.server.policy import EventHandlerPolicy
            cpc=oobj._oleobj_.QueryInterface(pythoncom.IID_IConnectionPointContainer)
            cp=cpc.FindConnectionPoint(self.CLSID_Sink)
            cookie=cp.Advise(win32com.server.util.wrap(self, usePolicy=EventHandlerPolicy))
            self._olecp,self._olecp_cookie = cp,cookie
    def __del__(self):
        try:
            self.close()
        except pythoncom.com_error:
            pass
    def close(self):
        if self._olecp is not None:
            cp,cookie,self._olecp,self._olecp_cookie = self._olecp,self._olecp_cookie,None,None
            cp.Unadvise(cookie)
    def _query_interface_(self, iid):
        import win32com.server.util
        if iid==self.CLSID_Sink: return win32com.server.util.wrap(self)

    # Event Handlers
    # If you create handlers, they should have the following prototypes:


from win32com.client import CoClassBaseClass
# This CoClass is known by the name 'DDC4100.DDC4100Ctrl.1'
class DDC4100(CoClassBaseClass): # A CoClass
    # DDC4100 Control
    CLSID = IID('{5C75C113-9AFC-42AC-8CED-1ABFE27763B5}')
    coclass_sources = [
        _DDDC4100Events,
    ]
    default_source = _DDDC4100Events
    coclass_interfaces = [
        _DDDC4100,
    ]
    default_interface = _DDDC4100

RecordMap = {
}

CLSIDToClassMap = {
    '{C4374661-BB24-410F-9BEB-5DED735F4985}' : _DDDC4100,
    '{5C75C113-9AFC-42AC-8CED-1ABFE27763B5}' : DDC4100,
    '{0CC72AA0-956F-48BD-9118-4446866ECBE3}' : _DDDC4100Events,
}
CLSIDToPackageMap = {}
win32com.client.CLSIDToClass.RegisterCLSIDsFromDict( CLSIDToClassMap )
VTablesToPackageMap = {}
VTablesToClassMap = {
}


NamesToIIDMap = {
    '_DDDC4100Events' : '{0CC72AA0-956F-48BD-9118-4446866ECBE3}',
    '_DDDC4100' : '{C4374661-BB24-410F-9BEB-5DED735F4985}',
}

I then used Dispatch to create the control object.
from win32com.client import Dispatch
DDC4100 = Dispatch('DDC4100.DDC4100Ctrl.1')

Now when I attept to call one of the functions from the wrapper I am presented with an error.
DDC4100.AboutBox()
Traceback (most recent call last):
File "<interactive input>", line 1, in <module>
File "C:\Python27\lib\site-packages\win32com\client\dynamic.py", line 505, in   __getattr__
ret = self._oleobj_.Invoke(retEntry.dispid,0,invoke_type,1)
com_error: (-2147418113, 'Catastrophic failure', None, None)

It seems like the makepy wrapper is not automatically being loaded and so I attempted using the EnsureModule() function form gencache and I still recieve the same error. At this point I do not know what to do since I have gone through this same process with a couple other programs within the registered type libraries and have had no problems. Does anyone see any errors in my methods or logic or know of a different way to go about using an ActiveX control?

-------------

https://stackoverflow.com/questions/12039174/python-activex-automation

I am trying to use ActiveX automation with python to control Audio Precision ATS-2. I am using pywin32 32-bit Windows XP with Python 2.7. 

I installed the audio Precision software. Then I used makepy utility which found Audio Precision in the list and created a wrapper for it. Everything is going well until I attempt to call dispatch function abd I am stuck. 

from guides I found online,
win32com.client.Dispatch("Excel.Application")

What should I put in the area that says "Excel.Application"?

How can I find this? 

When I used OLE/COM Object viewer, I see Audio Precision entries under type library, but I am unsure how does the information in it could help me.

I have attempted few things on my own, but got almost no result. The best result I got was when I entered the CLSID in dispatch function, which I found in the wrapper object makepy created.
win32com.client.Dispatch("{80EC6E76-D94F-48EB-8F4C-05BDD7850BF1}")

which gave me the following error:
    Traceback (most recent call last):
  File "C:\Python27\Lib\site-packages\win32com\gen_py\APtest.py", line 5, in <module>
    xlApp = win32com.client.Dispatch("{80EC6E76-D94F-48EB-8F4C-05BDD7850BF1}")
  File "C:\Python27\lib\site-packages\win32com\client\__init__.py", line 95, in Dispatch
    dispatch, userName = dynamic._GetGoodDispatchAndUserName(dispatch,userName,clsctx)
  File "C:\Python27\lib\site-packages\win32com\client\dynamic.py", line 108, in _GetGoodDispatchAndUserName
    return (_GetGoodDispatch(IDispatch, clsctx), userName)
  File "C:\Python27\lib\site-packages\win32com\client\dynamic.py", line 85, in _GetGoodDispatch
    IDispatch = pythoncom.CoCreateInstance(IDispatch, None, clsctx, pythoncom.IID_IDispatch)
com_error: (-2147221164, 'Class not registered', None, None)

I am trying to use ActiveX automation with python to control Audio Precision ATS-2. I am using pywin32 32-bit Windows XP with Python 2.7. 

I installed the audio Precision software. Then I used makepy utility which found Audio Precision in the list and created a wrapper for it. Everything is going well until I attempt to call dispatch function abd I am stuck. 

from guides I found online,
win32com.client.Dispatch("Excel.Application")

What should I put in the area that says "Excel.Application"?

How can I find this? 

When I used OLE/COM Object viewer, I see Audio Precision entries under type library, but I am unsure how does the information in it could help me.

I have attempted few things on my own, but got almost no result. The best result I got was when I entered the CLSID in dispatch function, which I found in the wrapper object makepy created.
win32com.client.Dispatch("{80EC6E76-D94F-48EB-8F4C-05BDD7850BF1}")

which gave me the following error:
    Traceback (most recent call last):
  File "C:\Python27\Lib\site-packages\win32com\gen_py\APtest.py", line 5, in <module>
    xlApp = win32com.client.Dispatch("{80EC6E76-D94F-48EB-8F4C-05BDD7850BF1}")
  File "C:\Python27\lib\site-packages\win32com\client\__init__.py", line 95, in Dispatch
    dispatch, userName = dynamic._GetGoodDispatchAndUserName(dispatch,userName,clsctx)
  File "C:\Python27\lib\site-packages\win32com\client\dynamic.py", line 108, in _GetGoodDispatchAndUserName
    return (_GetGoodDispatch(IDispatch, clsctx), userName)
  File "C:\Python27\lib\site-packages\win32com\client\dynamic.py", line 85, in _GetGoodDispatch
    IDispatch = pythoncom.CoCreateInstance(IDispatch, None, clsctx, pythoncom.IID_IDispatch)
com_error: (-2147221164, 'Class not registered', None, None)

I have:
•looked under the registry, and the ID is indeed not registered anywhere. There are few Audio Precision entries, but doesn't look like it has anything that could fix this.
•attempted reinstalling the Audio Precision software, but it didn't help.
•attempted to register the dll objects in the Audio Precision control(ATS 1.60) software with regsrv32, but all gave errors and would not register(which I suspect aren't the right ones I need to register)

How can I fix this?

Possible way to solve this:
•Identify the Audio Precision ATS-2 dll you want to call. E.g. "C:\path\my.dll"
•Now go to the registry and look for "C:\path\my.dll". You'll find a few things around but what you really want is an entry in CLSID...\InprocServer32 folder, or something similar
•There will be a ProgID entry as well, something like "AudioPrecison.ATS2"
•Now in Python try win32com.client.Dispatch("AudioPrecison.ATS2")

To use the pywin32 module with an activex class you need to generate a wrapper file. To do this locate your makepy.py file in C:\Python27\Lib\site-packages\win32com\client (or your similar dir). Then run it, locate the NAME of your activex class then run it. It should generate a wrapper file in the gen_py folder C:\Python27\Lib\site-packages\win32com\gen_py with the CLSID in it. You can then access it like the excel example and the same way you would in other languages.

I had the same issue. I didn't know where to get that, which from what I can gather is the name of the CoClass (which I believe is the wrapper for the dll) created by the makepy program (maybe I'm wrong). After I read the answer by @NotAUser I found it, but when I inspected the file created by the makepy program, and right before the last class, (if more than one are created) I found the following:
from win32com.client import CoClassBaseClass
# This CoClass is known by the name 'ZKFPEngXControl.ZKFPEngX'
class ZKFPEngX(CoClassBaseClass): # A CoClass

So, there, in the same file there was the name I needed to use.

================

https://stackoverflow.com/questions/3940498/is-there-a-tool-for-exploring-testing-com-objects

I'm trying to automate a process by using a COM object from Python (win32com), but I'm not getting the expected results... Is there a tool to explore/test COM objects without having to write a specific program? I mean, is there something that allows e.g. to instantiate a COM object and call its methods?

If you download the Windows SDK via the WebSetup you should be able to choose to just download the SDK tools. They include a program called Ole/COM Viewer (oleview.exe) that can be used to browse all registered COM objects, and for objects that support Ole Automation, open them and invoke methods.
https://www.microsoft.com/en-us/download/details.aspx?id=3138

I am exploring COM objects in PowerShell. Found this great recipe, provided by Jaap Brasser, which is easy to run and answered my question.
[ecr: http://www.powershellmagazine.com/2013/06/27/pstip-get-a-list-of-all-com-objects-available/]


Get a list of all Com objects available Posted by Jaap Brasser on June 27, 2013 

Note: This tip requires PowerShell 2.0 or above.

Recently a question was posted on the PowerShell.com forums: How to get a full list of available ComObjects? This tip will show how fetch all of them from the registry.

Here is the code that we can use to generate this list:
Get-ChildItem HKLM:\Software\Classes -ErrorAction SilentlyContinue | Where-Object {
   $_.PSChildName -match '^\w+\.\w+$' -and (Test-Path -Path "$($_.PSPath)\CLSID")
} | Select-Object -ExpandProperty PSChildName


The first Cmdlet reads out a complete list of values from HKLM:\Software\Classes and then verifies if the following two conditions are true:
•Does the object match the naming convention for a ComObject?

•Does the registry key have a CLSID folder? Every registered ComObject should have a CLSID as a unique identifier. An example of the output generated by this command is as follows:

AccClientDocMgr.AccClientDocMgr
 AccDictionary.AccDictionary
 Access.ACCDAExtension
 Access.ACCDCFile
 Access.ACCDEFile
 Access.ACCDTFile
 Access.ACCFTFile
 Access.ADEFile 


To make the process of discovering ComObject easier the following function can be used.
function Get-ComObject {

    param(
        [Parameter(Mandatory=$true,
        ParameterSetName='FilterByName')]
        [string]$Filter,

        [Parameter(Mandatory=$true,
        ParameterSetName='ListAllComObjects')]
        [switch]$ListAll
    )

    $ListofObjects = Get-ChildItem HKLM:\Software\Classes -ErrorAction SilentlyContinue | Where-Object {
        $_.PSChildName -match '^\w+\.\w+$' -and (Test-Path -Path "$($_.PSPath)\CLSID")
    } | Select-Object -ExpandProperty PSChildName

    if ($Filter) {
        $ListofObjects | Where-Object {$_ -like $Filter}
    } else {
        $ListofObjects
    }
}


This function is available in the TechNet Script Gallery:

http://gallery.technet.microsoft.com/Get-ComObject-Function-to-50a92047

--------------

http://www.npackd.org/p/com.microsoft.OLEView/1.0.0.1

 OLE/COM Object Viewer 1.0.0.1 

Full internal name: com.microsoft.OLEView 
Project site: http://msdn.microsoft.com/en-us/library/windows/desktop/ms688269(v=vs.85).aspx 
Screen shots:  
Download: ? Download OLE/COM Object Viewer 1.0.0.1

http://download.microsoft.com/download/win2000platform/oleview/1.00.0.1/NT5/EN-US/oleview_setup.exe 
Change log: n/a 
Description: 
OLE/COM object viewer
 
License: OLE/COM Object Viewer license 
Version: 1.0.0.1 
SHA-1 or SHA-256: 07ee66105f30884b2daa12c6d46c83e201a98f38 
Type: one file 
Dependencies:  
Tags: stable 
Text files: 

Detection (optional):  
Last modified: Wed Oct 16 15:33:00 UTC 2013 
Last modified by: tim.lebedk... 
Created: Wed Oct 16 15:33:00 UTC 2013 
Created by: tim.lebedk... 
Automated tests: 14 of 15 installations succeeded, 14 of 14 removals succeeded 

==============

Turtle:

https://fiftyexamples.readthedocs.io/en/latest/index.html
50 Examples for Teaching Python
enige hst'n uit dit boek

https://fiftyexamples.readthedocs.io/en/latest/gravity.html
Simulating Planetary Orbits

daarnaast heeft ie Monty Hall simulatie, Conway, big O notation

-----------

www.101computing.net/python-turtle-spirograph/
een punt op een cirkel die draait binnen een andere cirkel, enz

===========

muziek met beep():

https://social.technet.microsoft.com/wiki/contents/articles/20989.music-from-the-command-line-performed-by-powershell.aspx
"Music from the command line"
performed by PowerShell

3 liedjes met beep() en sleep()

jeffwouters.nl/index.php/2012/03/get-your-geek-on-with-powershell-and-some-music/
de originelen + extra versies in commentaar

PowerShell:
$([char]7)
1..100 | % {$([char]7}

-----------

https://www.autoitscript.com/forum/topic/40848-beep-music-mario-bros-theme/
https://connysoderholm.com/playing-super-mario-theme-music-with-python/


https://github.com/ShaneMcC/beeps
collection of beep scripts

https://github.com/NaWer/beep
collection of bash scripts

https://inphamousdevelopment.wordpress.com/2012/11/12/beep-beep/
tetris in C# met Console.Beep(). Zou niet werken in win7 64-bit, maar anderen
zeggen wel in C.

===============

https://marc.info/?l=python-list&r=1&w=2
->overzicht alle msgs van python-list

https://marc.info/?l=python-list&m=97613475409872&w=2
->rotate ellipse

List:       python-list
Subject:    Re: rotate() in Tkinter
From:       Stephen D Evans <stevee () recombinant ! demon ! co ! uk>
Date:       2000-12-06 20:28:50
[Download RAW message or body]

To rotate an oval convert the oval to a polygon and rotate that. Polygons are
easy to rotate, but this has to be done to the points before calling
create_polygon().

Referring to Tk documentation - The canvas does not support rotation.
'Practical Programming in Tcl and Tk', 3rd edition, 2000, by Brent B. Welsh,
publisher Prentice Hall PTR

This is a simple example.

(There are better methods of creating the points for an oval. Try fast
generation of ellipsoids in 'Graphics Gems V', 1995, edited by Alan W Paeth,
publisher AP Professional)

import math
import Tkinter


def poly_oval(x0,y0, x1,y1, steps , rotation=0):
    """return an oval as coordinates suitable for create_polygon"""

    # x0,y0,x1,y1 are as create_oval

    # rotation is in degrees anti-clockwise, convert to radians
    rotation = rotation * math.pi / 180.0

    # major and minor axes
    a = (x1 - x0) / 2.0
    b = (y1 - y0) / 2.0

    # center
    xc = x0 + a
    yc = y0 + b

    point_list = []

    # create the oval as a list of points
    for i in range(steps):

        # Calculate the angle for this step
        # 360 degrees == 2 pi radians
        theta = (math.pi * 2) * (float(i) / steps)

        x1 = a * math.cos(theta)
        y1 = b * math.sin(theta)

        # rotate x, y
        x = (x1 * math.cos(rotation)) + (y1 * math.sin(rotation))
        y = (y1 * math.cos(rotation)) - (x1 * math.sin(rotation))

        point_list.append(round(x + xc))
        point_list.append(round(y + yc))

    return point_list

import Tkinter
root = Tkinter.Tk()
canvas = Tkinter.Canvas(root, width@0, height@0)

dict = {}
dict['outline'] = 'black'
dict['fill']   = 'yellow'
dict['smooth'] = 'true'

# use a polygon to draw an oval rotated 30 degrees anti-clockwise
apply(canvas.create_polygon, tuple(poly_oval(40,40, 200,300, rotation0)),
dict)

canvas.pack()
root.mainloop()

-- Stephen D Evans




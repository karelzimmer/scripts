
ncoi: pip zit in:
C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Scripts

>pip install xyz

haalt data uit PyPI (=Python Package Index, https://pypi.python.org/pypi)

===========

# contact zoeken met sql express en Northwind db

# sqlexpress 2008R2 64-bit geinstalleerd
# sql server configuration manager:
#   service: sql server browser ->automatic, start (stond disabled)
#   eventueel volgende, maar niet nodig met pypyodbc:
#   node: sql server network configuration\Protocols for SQLEXPRESS ->TCP/IP enabled (stond disabled)
# sql express management studio geinstalleerd
# dir: c:\SqlDatabases met Northwind en pubs db naar C:\ gekopieerd
# mgmt studio: Northwind en pubs ge-attached

# python: library pypyodbc opgehaald met pip
#   ncoi: pip staat in:
# C:\>cd C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Scripts
# pip install pypyodbc
#   haalt data uit PyPI (=Python Package Index, https://pypi.python.org/pypi)
#   imports komen in:
#   C:\Users\Cursist\AppData\Local\Programs\Python\Python35-32\Lib\site-packages


===========

https://wiki.python.org/moin/SQL%20Server

info over allerlei sql drivers, incl. linkjes

pyodbc
http://code.google.com/p/pyodbc 

LicenseMIT Platforms
Windows, Linux, MacOS X, FreeBSD, Solaris, Any (source provided) Python versions2.4 - 3.2 
Actively maintained Open Source project. 

Precompiled binaries are available for Windows. RedHat Enterprise Linux, Centos, and Fedora have precompiled RPMs available in their Extras repositories. 

Supports ANSI and Unicode data and SQL statements and includes an extensive set of unit tests for SQL Server. pyODBC require ODBC driver to work correctly with SQL Server. You may download latest SQL Server ODBC driver and use it freely. Or you may choose Microsoft ODBC driver for that needs which is posted above in mxODBC driver description. 

pypyodbc (Pure Python)
http://code.google.com/p/pypyodbc

LicenseMIT PlatformsWindows, Linux Python versions2.4 - 3.3 
A Hello World script of pypyodbc database programing 

Connect SQL Server in 3 steps with pypyodbc on Linux 

Run SQLAlchemy on PyPy with pypyodbc driver 

PyPyODBC is a pure Python script, it runs on CPython / IronPython / PyPy , Version 2.4 / 2.5 / 2.6 / 2.7 , Win / Linux , 32 / 64 bit. 

Almost totally same usage as pyodbc ( can be seen as a re-implementation of pyodbc in pure Python ). 

Simple - the whole module is implemented in a single python script with less than 3000 lines. 

Built-in Access MDB file creation and compression functions on Windows. 

==============

http://code.google.com/p/pypyodbc

pypyodbc - A pure Python ODBC interface module based on ctypes

Design Goal: Small, Compatible, Cross Platfrom, Portable, Maintainable

Latest release: 1.3.3 May 25 2014

#Access mdb:
Simply try pypyodbc: ``` import pypyodbc 

pypyodbc.win_create_mdb('D:\database.mdb')

connection_string = 'Driver={Microsoft Access Driver (*.mdb)};DBQ=D:\database.mdb'

connection = pypyodbc.connect(connection_string)

SQL = 'CREATE TABLE saleout (id COUNTER PRIMARY KEY,product_name VARCHAR(25));'

connection.cursor().execute(SQL).commit()

Download & Install

Download the package from PYPI , unzip to a folder, double click the setup.py file, or run  setup.py install 

Or if you have pip available:  pip install pypyodbc

===========

https://blogs.msdn.microsoft.com/cdndevs/2015/03/11/python-and-data-sql-server-as-a-data-source-for-python-applications/

pip met pypyodbc

pypyodbc.connect(‘Driver = {drivername};Server=servername; Database=databaseName; uid=username;pwd=password)
•Driver – identifies the driver you wish to use to connect to the database, the correct driver to use will depend on which database product you are using. Since we are using SQL Server, our driver should be SQL Server
•Server – identifies the server where SQL Server is running. If you are running SQL Server on the same PC where you are running your Python code the server name will be localhost
•Database – is the name of your database in SQL Server. I have created a database called testdb.
•uid and pwd – are the SQL Server username and password that has permissions to log into the database and perform the desired actions. In this example I am logging in with the default sys admin password sa.

import pypyodbc
connection = pypyodbc.connect('Driver={SQL Server};'
                                'Server=localhost;'
                                'Database=testdb;'
                                'uid=sa;pwd=P@ssw0rd')
connection.close()

#insert
cursor = connection.cursor()
SQLCommand = ("INSERT INTO Customers (firstName, lastName, city) "
                 "VALUES (?,?,?)")
Values = ['Susan','Ibach','Toronto']
cursor.execute(SQLCommand,Values)
connection.commit()
connection.close()

#read one row
cursor = connection.cursor()
SQLCommand = ("SELECT firstname, lastname, city "
               "FROM customers "
               "WHERE customerid = ?")
Values = [2]
cursor.execute(SQLCommand,Values)
results = cursor.fetchone()
print("Your customer " + results[0] + " " + results[1] + " lives in " + results[2]) connection.close()

#read all rows
cursor = connection.cursor() 
SQLCommand = ("SELECT customerid, firstname, lastname, city "
               "FROM customers")
cursor.execute(SQLCommand)
results = cursor.fetchone()
while results:
     print ("Your customer " +  str(results[0]) + " " + results[1] + " lives in " + results[2])
     results = cursor.fetchone()
connection.close()

=============

https://msdn.microsoft.com/library/mt715796.aspx

2 drivers: pyodbc, pymssql


import pymssql  
conn = pymssql.connect(server='yourserver.database.windows.net', user='yourusername@yourserver', password='yourpassword', database='AdventureWorks') 

cursor = conn.cursor()  

cursor.execute('SELECT c.CustomerID, c.CompanyName,COUNT(soh.SalesOrderID) AS OrderCount FROM SalesLT.Customer AS c LEFT OUTER JOIN SalesLT.SalesOrderHeader AS soh ON c.CustomerID = soh.CustomerID GROUP BY c.CustomerID, c.CompanyName ORDER BY OrderCount DESC;')  

row = cursor.fetchone()  
while row:  
    print str(row[0]) + " " + str(row[1]) + " " + str(row[2])     
    row = cursor.fetchone()

cursor.execute("INSERT SalesLT.Product (Name, ProductNumber, StandardCost, ListPrice, SellStartDate) OUTPUT INSERTED.ProductID VALUES ('SQL Server Express', 'SQLEXPRESS', 0, 0, CURRENT_TIMESTAMP)")  

row = cursor.fetchone()  
while row:  
    print "Inserted Product ID : " +str(row[0])  
    row = cursor.fetchone()  
conn.commit()
conn.close()

cursor.execute("BEGIN TRANSACTION")  
cursor.execute("INSERT SalesLT.Product (Name, ProductNumber, StandardCost, ListPrice, SellStartDate) OUTPUT INSERTED.ProductID VALUES ('SQL Server Express New', 'SQLEXPRESS New', 0, 0, CURRENT_TIMESTAMP)")  
conn.rollback()  
conn.close()

===============

https://msdn.microsoft.com/en-us/library/mt694094.aspx


Install Python runtime and pip package manager
 a. Go to python.org
 b. Click on the appropriate Windows installer msi link.
 c. Once downloaded run the msi to install Python runtime


2.Download pymssql module from here
http://www.lfd.uci.edu/~gohlke/pythonlibs/#pymssql
Use pip version 8 or newer to install the downloaded .whl files. This page is not a pip package index.


Make sure you choose the correct whl file. For example : If you are using Python 2.7 on a 64 bit machine choose : pymssql-2.1.1-cp27-none-win_amd64.whl. Once you download the .whl file place it in the the C:/Python27 folder.


3.Open cmd.exe


4.Install pymssql module
 For example, if you are using Python 2.7 on a 64 bit machine:

> cd c:\Python27  
> pip install pymssql-2.1.1-cp27-none-win_amd64.whl

=============

http://pymssql.org/en/stable/pymssql_examples.html#important-note-about-cursors

goede voorbeelden

#Basic features (strict DB-API compliance)

from os import getenv
import pymssql

server = getenv("PYMSSQL_TEST_SERVER")
user = getenv("PYMSSQL_TEST_USERNAME")
password = getenv("PYMSSQL_TEST_PASSWORD")

conn = pymssql.connect(server, user, password, "tempdb")
cursor = conn.cursor()
cursor.execute("""
IF OBJECT_ID('persons', 'U') IS NOT NULL
    DROP TABLE persons
CREATE TABLE persons (
    id INT NOT NULL,
    name VARCHAR(100),
    salesrep VARCHAR(100),
    PRIMARY KEY(id)
)
""")
cursor.executemany(
    "INSERT INTO persons VALUES (%d, %s, %s)",
    [(1, 'John Smith', 'John Doe'),
     (2, 'Jane Doe', 'Joe Dog'),
     (3, 'Mike T.', 'Sarah H.')])
# you must call commit() to persist your data if you don't set autocommit to True
conn.commit()

cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')
row = cursor.fetchone()
while row:
    print("ID=%d, Name=%s" % (row[0], row[1]))
    row = cursor.fetchone()

conn.close()

---------

#Iterating through results
#You can also use iterators instead of while loop.
#Iterators are a pymssql extension to the DB-API.

conn = pymssql.connect(server, user, password, "tempdb")
cursor = conn.cursor()
cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')

for row in cursor:
    print('row = %r' % (row,))

conn.close()

----------

Important note about Cursors

A connection can have only one cursor with an active query at any time. If you have used other Python DBAPI databases, this can lead to surprising results:


c1 = conn.cursor()
c1.execute('SELECT * FROM persons')

c2 = conn.cursor()
c2.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')

print( "all persons" )
print( c1.fetchall() )  # shows result from c2 query!

print( "John Doe" )
print( c2.fetchall() )  # shows no results at all!


In this example, the result printed after "all persons" will be the result of the second query (the list where salesrep='John Doe') and the result printed after “John Doe” will be empty. This happens because the underlying TDS protocol does not have client side cursors. The protocol requires that the client flush the results from the first query before it can begin another query.

(Of course, this is a contrived example, intended to demonstrate the failure mode. Actual use cases that follow this pattern are usually much more complicated.)

Here are two reasonable workarounds to this:

•Create a second connection. Each connection can have a query in progress, so multiple connections can execute multiple conccurent queries.


•use the fetchall() method of the cursor to recover all the results before beginning another query:


c1.execute('SELECT ...')
c1_list = c1.fetchall()

c2.execute('SELECT ...')
c2_list = c2.fetchall()

# use c1_list and c2_list here instead of fetching individually from
# c1 and c2

-------------

Rows as dictionaries

Rows can be fetched as dictionaries instead of tuples. This allows for accessing columns by name instead of index. Note the as_dict argument.


conn = pymssql.connect(server, user, password, "tempdb")
cursor = conn.cursor(as_dict=True)

cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')
for row in cursor:
    print("ID=%d, Name=%s" % (row['id'], row['name']))

conn.close()

The as_dict parameter to cursor() is a pymssql extension to the DB-API.

-------------

Using the with statement (context managers)

You can use Python’s with statement with connections and cursors. This frees you from having to explicitly close cursors and connections.


with pymssql.connect(server, user, password, "tempdb") as conn:
    with conn.cursor(as_dict=True) as cursor:
        cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')
        for row in cursor:
            print("ID=%d, Name=%s" % (row['id'], row['name']))

The context manager personality of connections and cursor is a pymssql extension to the DB-API.

------------

Calling stored procedures

As of pymssql 2.0.0 stored procedures can be called using the rpc interface of db-lib.


with pymssql.connect(server, user, password, "tempdb") as conn:
    with conn.cursor(as_dict=True) as cursor:
        cursor.execute("""
        CREATE PROCEDURE FindPerson
            @name VARCHAR(100)
        AS BEGIN
            SELECT * FROM persons WHERE name = @name
        END
        """)
        cursor.callproc('FindPerson', ('Jane Doe',))
        for row in cursor:
            print("ID=%d, Name=%s" % (row['id'], row['name']))

----------

Using pymssql with cooperative multi-tasking systems


New in version 2.1.0.

You can use the pymssql.set_wait_callback() function to install a callback function you should write yourself.

This callback can yield to another greenlet, coroutine, etc. For example, for gevent, you could use its gevent.socket.wait_read() function:


import gevent.socket
import pymssql

def wait_callback(read_fileno):
    gevent.socket.wait_read(read_fileno)

pymssql.set_wait_callback(wait_callback)


The above is useful if you’re say, running a Gunicorn server with the gevent worker. With this callback in place, when you send a query to SQL server and are waiting for a response, you can yield to other greenlets and process other requests. This is super useful when you have high concurrency and/or slow database queries and lets you use less Gunicorn worker processes and still handle high concurrency.

set_wait_callback() is a pymssql extension to the DB-API 2.0.

===============

http://pymssql.org/en/stable/_mssql_examples.html

Quickstart usage of various features


import _mssql
conn = _mssql.connect(server='SQL01', user='user', password='password', \
    database='mydatabase')
conn.execute_non_query('CREATE TABLE persons(id INT, name VARCHAR(100))')
conn.execute_non_query("INSERT INTO persons VALUES(1, 'John Doe')")
conn.execute_non_query("INSERT INTO persons VALUES(2, 'Jane Doe')")


# how to fetch rows from a table
conn.execute_query('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')
for row in conn:
    print "ID=%d, Name=%s" % (row['id'], row['name'])

New in version 2.1.0: Iterating over query results by iterating over the connection object just like it’s already possible with pymssql connections is new in 2.1.0.

# examples of other query functions
numemployees = conn.execute_scalar("SELECT COUNT(*) FROM employees")
numemployees = conn.execute_scalar("SELECT COUNT(*) FROM employees WHERE name LIKE 'J%'")   
# note that '%' is not a special character here
employeedata = conn.execute_row("SELECT * FROM employees WHERE id=%d", 13)

# how to fetch rows from a stored procedure
conn.execute_query('sp_spaceused')   # sp_spaceused without arguments returns 2 result sets
res1 = [ row for row in conn ]       # 1st result
res2 = [ row for row in conn ]       # 2nd result

# how to get an output parameter from a stored procedure
sqlcmd = """
DECLARE @res INT
EXEC usp_mystoredproc @res OUT
SELECT @res
"""
res = conn.execute_scalar(sqlcmd)

# how to get more output parameters from a stored procedure
sqlcmd = """
DECLARE @res1 INT, @res2 TEXT, @res3 DATETIME
EXEC usp_getEmpData %d, %s, @res1 OUT, @res2 OUT, @res3 OUT
SELECT @res1, @res2, @res3
"""
res = conn.execute_row(sqlcmd, (13, 'John Doe'))

# examples of queries with parameters
conn.execute_query('SELECT * FROM empl WHERE id=%d', 13)
conn.execute_query('SELECT * FROM empl WHERE name=%s', 'John Doe')
conn.execute_query('SELECT * FROM empl WHERE id IN (%s)', ((5, 6),))
conn.execute_query('SELECT * FROM empl WHERE name LIKE %s', 'J%')
conn.execute_query('SELECT * FROM empl WHERE name=%(name)s AND city=%(city)s', \
    { 'name': 'John Doe', 'city': 'Nowhere' } )
conn.execute_query('SELECT * FROM cust WHERE salesrep=%s AND id IN (%s)', \
    ('John Doe', (1, 2, 3)))
conn.execute_query('SELECT * FROM empl WHERE id IN (%s)', (tuple(xrange(4)),))
conn.execute_query('SELECT * FROM empl WHERE id IN (%s)', \
    (tuple([3, 5, 7, 11]),))

conn.close()

Please note the usage of iterators and ability to access results by column name. Also please note that parameters to connect method have different names than in pymssql module.

An example of exception handling


import _mssql

conn = _mssql.connect(server='SQL01', user='user', password='password',
                      database='mydatabase')
try:
    conn.execute_non_query('CREATE TABLE t1(id INT, name VARCHAR(50))')
except _mssql.MssqlDatabaseException as e:
    if e.number == 2714 and e.severity == 16:
        # table already existed, so quieten the error
    else:
        raise # re-raise real error
finally:
    conn.close()



Custom message handlers


New in version 2.1.1.

You can provide your own message handler callback function that will be invoked by the stack with informative messages sent by the server. Set it on a per _mssql connection basis by using the _mssql.MSSQLConnection.set_msghandler() method:


import _mssql

def my_msg_handler(msgstate, severity, srvname, procname, line, msgtext):
    """
    Our custom handler -- It simpy prints a string to stdout assembled from
    the pieces of information sent by the server.
    """


 print("my_msg_handler: msgstate = %d, severity = %d, procname = '%s', "
          "line = %d, msgtext = '%s'" % (msgstate, severity, procname,
                                         line, msgtext))

conn = _mssql.connect(server='SQL01', user='user', password='password')
try:
    conn.set_msghandler(my_msg_handler)  # Install our custom handler
    cnx.execute_non_query("USE mydatabase")  # It gets called at this point
finally:
    conn.close()


Something similar to this would be printed to the standard output:

my_msg_handler: msgstate = x, severity = y, procname = '', line = 1, msgtext = 'Changed database context to 'mydatabase'.'

Todo
Add an example of invoking a Stored Procedure using _mssql.


===============

http://pymssql.org/en/stable/intro.html

pip install pymssql

will install pymssql from PyPI.
https://pypi.python.org/pypi/pymssql

This PyPI page contains:
•source distribution (.tar.gz)
•wheels (.whl) for Windows

--------

http://pymssql.org/en/stable/freetds.html

Windows

You can:

1.Simply use our official Wheels which include FreeTDS statically linked and have no SSL support.

pymssql uses FreeTDS package to connect to SQL Server instances. You have to tell it how to find your database servers. The most basic info is host name, port number, and protocol version to use.

The system-wide FreeTDS configuration file is /etc/freetds.conf or C:\freetds.conf, depending upon your system. It is also possible to use a user specific configuration file, which is $HOME/.freetds.conf on Linux and %APPDATA%\.freetds.conf on Windows. Suggested contents to start with is at least:


[global]
    port = 1433
    tds version = 7.0


With this config you will be able to enter just the hostname to pymssql.connect() and _mssql.connect():


import pymssql
connection = pymssql.connect(server='mydbserver', ...)


Otherwise you will have to enter the portname as in:


connection = pymssql.connect(server='mydbserver:1433', ...)

To connect to instance other than the default, you have to know either the instance name or port number on which the instance listens:


connection = pymssql.connect(server='mydbserver\\myinstancename', ...)
# or by port number (suppose you confirmed that this instance is on port 1237)
connection = pymssql.connect(server='mydbserver:1237', ...)

Please see also the pymssql module reference, _mssql module reference, and FAQ pages.

For more information on configuring FreeTDS please go to http://www.freetds.org/userguide/freetdsconf.htm


Testing the connection

If you’re sure that your server is reachable, but pymssql for some reason don’t let you connect, you can check the connection with tsql utility which is part of FreeTDS package:


$ tsql
Usage:  tsql [-S <server> | -H <hostname> -p <port>] -U <username> [-P <password>] [-I <config file>] [-o <options>] [-t delim] [-r delim] [-D database]
(...)
$ tsql -S mydbserver -U user


Use the above form if and only if you specified server alias for mydbserver in freetds.conf. Otherwise use the host/port notation:


$ tsql -H mydbserver -p 1433 -U user


You’ll be prompted for a password and if the connection succeeds, you’ll see the SQL prompt:


1>


You can then enter queries and terminate the session with exit.

===========

http://stackoverflow.com/questions/1954128/how-do-i-connect-to-my-64-bit-sql-server-with-odbc

How do I connect to my 64-bit SQL Server with ODBC?

I recently installed SQL Server 2008 Express on my Windows 7 Ultimate x64 home machine. I also have IIS 7.5 with PHP 5.3, and I was trying to connect to SQL via ADODB, but kept getting this error:
[Microsoft][ODBC Driver Manager] The specified DSN contains an
architecture mismatch between the Driver and Application

After doing a small amount of digging on the internet, I think this is because the SQL Server ODBC driver is meant for 32-bit operating systems, and mine's 64. First of all, am I correct? Is this the reason I'm running into trouble? Secondly, if so, how do I fix this? Are there any updated ODBC drivers that work with 64-bit operating systems? I looked but was unable to find any...

6 Answers  

You're right in that it has to do with the bits.

Hope this helps:

--From MSDN --

To manage a data source that connects to a 32-bit driver under 64-bit platform, use
c:\windows\sysWOW64\odbcad32.exe.
To manage a data source that connects to a 64-bit driver, use
c:\windows\system32\odbcad32.exe.
If you use the 64-bit odbcad32.exe to configure or remove a DSN that connects to a 32-bit driver you will receive this message.

---

I'm betting you are working with User DSNs. 

Depending on your perspective, there's a "feature" or "bug" in the 64-bit Windows environment -- 

1.32-bit User DSNs show up in the 64-bit Administrator and when 64-bit client applications ask for all available DSNs -- even though the 32-bit DSNs cannot be used by the 64-bit client app and Adminstrator.


2.64-bit User DSNs show up in the 32-bit Administrator and when 32-bit client applications ask for all available DSNs -- even though the 64-bit DSNs cannot be used by the 32-bit client app and Adminstrator.


The error message you describe comes up anytime there's such a bitness mismatch between the DSN and the client trying to work with it.

Microsoft's recommendation is to name your User DSNs with _32 or _64, depending on the bitness of the driver on which they're based ... or stick with System DSNs.

There are 32-bit and 64-bit solutions for the connection you want. The bitness of your client application(s) -- IIS & PHP, in this case -- dictate the bitness of the solution you require.

-----

if 32 bit application on 64 bit operating system (the application you are installed under [program files (X86)] use the following C:\Windows\SysWOW64\odbcad32.exe

otherwise 64 bit application and 64 bit operating system use the following C:\Windows\System32\odbcad32.exe 

otherwise you will get a error like "Architectural mismatch"

Hope this will save someone's day :)

==============

http://stackoverflow.com/questions/10091232/setting-up-dsn-for-a-sql-server-express-database

setting up dsn for a sql server express database

How do i set up a system dsn for a 64 bit sql server express 2008 R2 that is installed on the local machine?

I go to add a system dsn and select sql server native client 10 and follow the wizard. However on the dropdown that asks which sql server to connect, i dont see any option for the local machine. Is there something that i need to enable??

Ignore the drop down and try typing in (local)\SQLEXPRESS and see if that works? 


Thank You that helped..i had a named instance of sql server..so i had to use (local)\nameoftheinstance and it worked!!! Thanks a lot...I also enabled named pipes in sql server configuration manager..is that necessary??? Thanks again. – cableload Apr 10 '12 at 15:17 

No problem. Sql Express always installs as a named instance called SQLExpress. You only need to enable named pipes if you are going to connect to it via named pipes. Some guidance on which protocol to use here. msdn.microsoft.com/en-us/library/ms187892%28v=sql.105%29.asp??x – Chris Diver Apr 10 '12 at 15:30   

===========

http://web.synametrics.com/sqlexpressremote.htm

Document information


Document ID:
1298 

Subject:
Configuring SQL Server Express to use TCP/IP for remote connections with ODBC 

Creation date:
4/22/10 9:56 AM 

Last modified on:
4/22/10 1:53 PM 



SQL Express and remote connections
TCP/IP is disable when you first install SQL Server Express on any machine. This KB article discusses how to enable TCP/IP the TCP/IP protocol and use an ODBC driver to connect to SQL Server Express. 

 For demonstration purposes we will be using the following tools:
•SQL Server Express 2008
•SQL Server ODBC driver
•WinSQL as an ODBC client

IMPORTANT: This article assumes you have enabled SQL Server authentication for client connections. 

 First, networking protocols are disabled by default in SQL Server Express. Thus, if someone simply installs Express and chooses all the defaults, SQL Server Express will only be able to have connections originating on the local machine where SQL Server is installed. 

 To enable SQL Server Express to accept remote connections we need to perform the following steps:

STEP 1: Enabling TCP/IP 

First we must tell SQL Server Express to listen on TCP/IP, to do this perform the following steps:
1.Launch the SQL Server Configuration Manager from the "Microsoft SQL Server 2008" Program menu 
2.Click on: SQL Server Network Configuration\Protocols for SQLEXPRESS
3.Right click on "TCP/IP" in the list of Protocols and choose, "Enable". Refer to the image below

STEP 2: Configure TCP/IP
1.Click on the "Protocols for SQLEXPRESS" node
2.Right click on the "TCP/IP" child node and select Properties
3.Ensure "Enabled" is set to "Yes" and "Listen All" is set to Yes. Refer to the image below.

4.Click the "IP Addresses" tab
5.Scroll down until you see IPAll
6.Remove the value for TCP Dynamic Ports
7.Enter the desired value for TCP Port. For demonstration purposes I am using 5171 for this value. Refer to the image below. 

STEP 3: Configuring the ODBC driver 

Following steps can be performed either from the same machine where SQL Server Express is installed or from any other machine.
1.Start WinSQL and select "Open ODBC Manager" under the "File" menu
2.Click "Add" button to add a new User DSN
3.Select "SQL Server" from the list. You might also see another driver called SQL Server Native Drive in the list. This driver, however, only supports Named Pipes as the network protocol and therefore, we do not select that one for this example. 
4.Next, specify a DNS name and the IP Address or host name of the machine. You can also specify "localhost" if both client and server are on the same machine. 

ecr: dlg
Name: Students
Description: DNS for student db
Server: 192.168.1.20
of: localhost

5.I leave Windows NT authentication on the next screen. If you running a client on a different operating system, such as Linux or Apple Mac, you will have to use SQL Server authentication. 
6.Click the "Client Configuration" button on the same screen
7.Uncheck "Dynamically determinate port" and specify a port number. In this example we are using 5171. 
8.Click Ok all the way to complete processing
9.Finally, launch WinSQL and specify the newly created DSN in the connection window.

===========

https://social.msdn.microsoft.com/Forums/en-US/54247476-e815-4626-930b-5972ca8fffd5/sql-2008-express-not-listening-on-port-1433?forum=sqlexpress#187738a6-7001-47a0-9240-61223ac06c7b

sql 2008 express not listening on port 1433

by default SQL Server Express does not enable Remote Connections.

Could you check the following:

1) check that the SQL Express is running (SQL Server Configuration Tool)

2) log onto the box containing the SQL Server and try to connect with SSMS to the SQL Express instance. Try tcp/ip and/or shared memory to connect.
    if you can successfully login check that the SQL Server does allow Remote Connections

3) Firewall does not block incoming connections

4) does the DNS server name resolve to the correct ip address of the SQL Server ?

Please check the SQL Server log file, at the beginning there is noted if the SQL Server is listening on TCP/IP protocoll and on which port.

You can open the log from SSMS => Management => SQL Server Logs.

Or you can open it from Windows Explorer, it' as simple text file. You will find it in C:\Program Files\Microsoft SQL Server\MSSQL10_50.SQLEXPRESS\MSSQL\Log

http://support.microsoft.com/kb/823938

Solved it.  I went to Protocols for SQLExpress, IP Address and then at the very bottom, set IPALL to 1433.  Restart SQL service.  Whala.  What a pain but works now.

==============

https://support.microsoft.com/en-us/kb/823938

How to configure SQL Server to listen on a specific port

By default, the default instance of SQL Server listens for requests from SQL Server clients on static port 1433. Therefore, the client network libraries assume that either port 1433 or the global default port that is defined for that client computer is used to connect to the default instance of SQL Server.

The default instance of SQL Server does not support dynamic port allocation. However, the named instances of SQL Server support allocation of both static and dynamic ports. By default, a named instance of SQL Server listens on a dynamic port. For a named instance of SQL Server, the SQL Server Browser service for SQL Server 2008, SQL Server 2005, or the SQL Server Resolution Protocol (SSRP) for SQL Server 2000 is always used to translate the instance name to a port, regardless of whether the port is static or dynamic. The Browser service or SSRP is never used for a default instance of SQL Server. 

Dynamic port allocation
 Only named instances of SQL Server can use the dynamic port allocation process. In the dynamic port allocation process, when you start the instance of SQL Server for the first time, the port is set to zero (0). Therefore, SQL Server requests a free port number from the operating system. As soon as a port number is allocated to SQL Server, SQL Server starts listening on the allocated port.

The allocated port number is written to the Windows registry. Every time that you start that named instance of SQL Server, it uses that allocated port number. However, in the unlikely case that another program that is already running on the computer is using that previously allocated (but not static) port number when you start SQL Server, SQL Server selects another port.

When you start the named instances of SQL Server the second time, SQL Server opens the listening port number that was started the first time, as follows:•If the port is opened without errors, SQL Server listens on the port.
•If the port is not opened, and errors occur, SQL Server behaves as follows:•You receive the following error message:
Error ID 10048 (WSAEADDRINUSE)
When you receive this error message, SQL Server determines that the port is being used. Then, the port number is set to zero (0) again. Therefore, an available port is assigned. And, SQL Server waits for the client connection request on the port.
•If you receive an error message that does not mention error 10048, SQL Server 2000 determines that it is impossible to wait for the connection request on the port. Therefore, the port is not opened.

Notes•In SQL Server 2005, when you receive the following error message, the port number is set to zero (0) and is opened.
Error ID 10013 (WSAEACCES)

When an instance of SQL Server uses dynamic port allocation, the connection string that is built at the SQL Server client does not specify the destination TCP/IP port unless the user or the programmer explicitly specifies the port. Therefore, the SQL Server client library queries the server on UDP port 1434 to collect the information about the destination instance of SQL Server. When SQL Server returns the information, the SQL Server client library sends the data to the appropriate instance of SQL Server.

If UDP port 1434 is disabled, the SQL Server client cannot dynamically determine the port of the named instance of SQL Server. Therefore, the SQL Server client may be unable to connect to the named instance of SQL Server. In this situation, the SQL Server client must specify the dynamically allocated port where the named instance of SQL Server 2008, SQL Server 2005, or SQL Server 2000 is listening.

A Named Instance of SQL Server is listening on port 1433.
If a Named Instance of SQL Server is listening on port 1433, the Microsoft OLE DB Provider for SQL Server (Provider=SQLOLEDB) and the SQL Server ODBC Driver (Driver={SQL Server}) may be unable to connect to the server. This failure to connect occurs when both the instance name and the port number from the connection string are omitted. If no port number is specified, the drivers validate the server instance name. If the server instance name is not the default instance, MSSQLSERVER, the connection is unsuccessful. To enable a successful connection, you must specify the instance name or the port number in the connection string or in a SQL Alias. 

Notes•We do not recommend that you have a named instance listen on port 1433.
•Other Providers, such as System.Data.SqlClient and SQL Native Client (Provider=SQLNCLI), do not perform the instance name check and connect successfully. 

===========

https://msdn.microsoft.com/en-us/library/ms175043.aspx

Configure a Windows Firewall for Database Engine Access

The principal steps to allow access are:

1.Configure the Database Engine to use a specific TCP/IP port. The default instance of the Database Engine uses port 1433, but that can be changed. The port used by the Database Engine is listed in the SQL Server error log. Instances of SQL Server Express, SQL Server Compact, and named instances of the Database Engine use dynamic ports. To configure these instances to use a specific port, see Configure a Server to Listen on a Specific TCP Port (SQL Server Configuration Manager).

2.Configure the firewall to allow access to that port for authorized users or computers.

 The SQL Server Browser service lets users connect to instances of the Database Engine that are not listening on port 1433, without knowing the port number. To use SQL Server Browser, you must open UDP port 1434. To promote the most secure environment, leave the SQL Server Browser service stopped, and configure clients to connect using the port number.

 By default, Microsoft Windows enables the Windows Firewall, which closes port 1433 to prevent Internet computers from connecting to a default instance of SQL Server on your computer. Connections to the default instance using TCP/IP are not possible unless you reopen port 1433. The basic steps to configure the Windows firewall are provided in the following procedures. For more information, see the Windows documentation.
 
As an alternative to configuring SQL Server to listen on a fixed port and opening the port, you can list the SQL Server executable (Sqlservr.exe) as an exception to the blocked programs. Use this method when you want to continue to use dynamic ports. Only one instance of SQL Server can be accessed in this way.

Configure a Windows Firewall for Database Engine Access

This topic describes how to configure a Windows firewall for Database Engine access in SQL Server 2016 by using SQL Server Configuration Manager. Firewall systems help prevent unauthorized access to computer resources. To access an instance of the SQL Server Database Engine through a firewall, you must configure the firewall on the computer running SQL Server to allow access.

For more information about the default Windows firewall settings, and a description of the TCP ports that affect the Database Engine, Analysis Services, Reporting Services, and Integration Services, see Configure the Windows Firewall to Allow SQL Server Access. There are many firewall systems available. For information specific to your system, see the firewall documentation.

The principal steps to allow access are:

1.Configure the Database Engine to use a specific TCP/IP port. The default instance of the Database Engine uses port 1433, but that can be changed. The port used by the Database Engine is listed in the SQL Server error log. Instances of SQL Server Express, SQL Server Compact, and named instances of the Database Engine use dynamic ports. To configure these instances to use a specific port, see Configure a Server to Listen on a Specific TCP Port (SQL Server Configuration Manager).


2.Configure the firewall to allow access to that port for authorized users or computers.

 The SQL Server Browser service lets users connect to instances of the Database Engine that are not listening on port 1433, without knowing the port number. To use SQL Server Browser, you must open UDP port 1434. To promote the most secure environment, leave the SQL Server Browser service stopped, and configure clients to connect using the port number.

 By default, Microsoft Windows enables the Windows Firewall, which closes port 1433 to prevent Internet computers from connecting to a default instance of SQL Server on your computer. Connections to the default instance using TCP/IP are not possible unless you reopen port 1433. The basic steps to configure the Windows firewall are provided in the following procedures. For more information, see the Windows documentation.
 
As an alternative to configuring SQL Server to listen on a fixed port and opening the port, you can list the SQL Server executable (Sqlservr.exe) as an exception to the blocked programs. Use this method when you want to continue to use dynamic ports. Only one instance of SQL Server can be accessed in this way.

In This Topic

•Before you begin:

Security
•To configure a Widows Firewall for Database Engine access, using:

SQL Server Configuration Manager

 Security

Opening ports in your firewall can leave your server exposed to malicious attacks. Make sure that you understand firewall systems before you open ports. For more information, see Security Considerations for a SQL Server Installation

Using SQL Server Configuration Manager

Applies to Windows Vista, Windows 7, and Windows Server 2008

The following procedures configure the Windows Firewall by using the Windows Firewall with Advanced Security Microsoft Management Console (MMC) snap-in. The Windows Firewall with Advanced Security only configures the current profile. For more information about the Windows Firewall with Advanced Security, see Configure the Windows Firewall to Allow SQL Server Access

To open a port in the Windows firewall for TCP access

1.On the Start menu, click Run, type WF.msc, and then click OK.

2.In the Windows Firewall with Advanced Security, in the left pane, right-click Inbound Rules, and then click New Rule in the action pane.

3.In the Rule Type dialog box, select Port, and then click Next.

4.In the Protocol and Ports dialog box, select TCP. Select Specific local ports, and then type the port number of the instance of the Database Engine, such as 1433 for the default instance. Click Next.

5.In the Action dialog box, select Allow the connection, and then click Next.

6.In the Profile dialog box, select any profiles that describe the computer connection environment when you want to connect to the Database Engine, and then click Next.

7.In the Name dialog box, type a name and description for this rule, and then click Finish.

To open access to SQL Server when using dynamic ports

1.On the Start menu, click Run, type WF.msc, and then click OK.

2.In the Windows Firewall with Advanced Security, in the left pane, right-click Inbound Rules, and then click New Rule in the action pane.

3.In the Rule Type dialog box, select Program, and then click Next.

4.In the Program dialog box, select This program path. Click Browse, and navigate to the instance of SQL Server that you want to access through the firewall, and then click Open. By default, SQL Server is at C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Binn\Sqlservr.exe. Click Next.

5.In the Action dialog box, select Allow the connection, and then click Next.

6.In the Profile dialog box, select any profiles that describe the computer connection environment when you want to connect to the Database Engine, and then click Next.

7.In the Name dialog box, type a name and description for this rule, and then click Finish.

===========

https://msdn.microsoft.com/en-us/library/cc646023.aspx

Configure the Windows Firewall to Allow SQL Server Access

ecr: heel veel info. o.a. Ports Used By SQL Server

=============

http://mkleehammer.github.io/pyodbc/

Connection example: Windows, without a DSN, using the Windows SQL Server driver
cnxn = pyodbc.connect('DRIVER={SQL Server};SERVER=localhost;PORT=1433;DATABASE=testdb;UID=me;PWD=pass')

# Connection example: Linux, without a DSN, using the FreeTDS driver
cnxn = pyodbc.connect('DRIVER={FreeTDS};SERVER=localhost;PORT=1433;DATABASE=testdb;UID=me;PWD=pass;TDS_Version=7.0')

# Connection example: with a DSN
cnxn = pyodbc.connect('DSN=test;PWD=password')

cursor.execute("select user_id, user_name from users")
row = cursor.fetchone()
print('name:', row[1])         # access by column index
print('name:', row.user_name)  # or access by name

Cursor.fetchall returns all remaining rows in a list. If there are no rows, an empty list is returned. (If there are a lot of rows, this will use a lot of memory. Unread rows are stored by the database driver in a compact format and are often sent in batches from the database server. Reading in only the rows you need at one time will save a lot of memory.)

cursor.execute("select user_id, user_name from users")
rows = cursor.fetchall()
for row in rows:
    print(row.user_id, row.user_name)

=============

https://code.google.com/archive/p/pypyodbc/issues

https://code.google.com/archive/p/pypyodbc/

===========

accdb:
[ecr: nw Access db fmt vanaf 2007 -> xyz.accdb ->vereist speciale odbc drivers
controleren of al aanwezig: Adm Tools (evt via Control Panel), Data Sources (ODBC)
->tab Drivers ->Microsoft Access Driver (*.mdb, *.accdb)
->dit is de 64bit versie; werkt niet met Python32
]

https://www.microsoft.com/en-US/download/details.aspx?id=13255

Microsoft Access Database Engine 2010 Redistributable

->bij klik op knop Download kun je de 32bit en 64bit versie beide aanvinken

Version: SP2

File Name: 
AccessDatabaseEngine.exe         25.3 MB
AccessDatabaseEngine_X64.exe     27.3 MB

Note: Before installing this download, you must first remove any previous versions of the Access Database Engine from your computer by using Add/Remove Programs in the Control Panel. 

To install this download:  1.Download the file by clicking the Download button and saving the file to your hard disk. 
2.Double-click the AccessDatabaseEngine.exe program file on your hard disk to start the setup program. 
3.Follow the instructions on the screen to complete the installation. 

To use this download:
If you use OLEDB, set the Provider of the ConnectionString to “Microsoft.ACE.OLEDB.12.0” 

If you are connecting to Microsoft Office Excel data, add the appropriate Extended Properties of the OLEDB connection string based on the Excel file type: 

 File Type (extension)                               Extended Properties
 --------------------------------------------------------------------------------
 Excel 97-2003 Workbook (.xls)                       "Excel 8.0"
 Excel 2007-2010 Workbook (.xlsx)                    "Excel 12.0 Xml"
 Excel 2007-2010 Macro-enabled workbook (.xlsm)      "Excel 12.0 Macro"
 Excel 2007-2010 Non-XML binary workbook (.xlsb)     "Excel 12.0"


3.Access: cnstring = “Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=path to mdb/accdb file” 
4.Excel: cnstring = “Driver={Microsoft Excel Driver (*.xls, *.xlsx, *.xlsm, *.xlsb)};DBQ=path to xls/xlsx/xlsm/xlsb file”




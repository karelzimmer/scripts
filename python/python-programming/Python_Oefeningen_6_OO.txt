Deel 6. Object Oriëntatie

Enige oefeningen met de class Auto en de afgeleide class Vrachtauto.
De auto's kunnen tanken, starten, rijden, sturen en stoppen. Een vrachtauto kan daarnaast een lading inladen, uitladen en tonen.

Een class is een bouwtekening voor een object. Je kunt meerdere objecten met dezelfde bouwtekening maken, bv de rijtjeshuizen in een straat. Zulke objecten hebben allemaal dezelfde structuur, met dezelfde variabelen en functies (methoden), maar wel steeds andere waarden voor de variabelen. Het ene huis heeft een bruine deur, het andere een blauwe deur, maar wel hebben ze allemaal een deur.
Daarnaast kan een class static variabelen en functies hebben, die door alle objecten gedeeld worden. Ieder huis heeft een eigen voordeur, maar alle huizen delen dezelfde straat of dezelfde stad. Zo heeft iedere radio zijn eigen volumeknop, maar delen alle radio's dezelfde FM-band.

Een afgeleide class (subclass) is gebaseerd op de bouwtekening van een andere class, maar heeft extra variabelen en/of functies. Python objecten hebben nog allerlei extra mogelijkheden, maar die vallen buiten het bestek van deze oefening.


[1] Base class Auto

1. Maak een nieuwe module ex6_autos.py. Declareer in de module een class Auto. Bij conventie beginnen class-namen altijd met een hoofdletter. Declareer bovenin de class een private variabele __garage met waarde 'Hendrikse'. Private variabelen in een class beginnen altijd met twee underscores. Een private variabele in een module begint met een underscore. Variabelen die je rechtstreeks in de class declareert, zijn per definitie static. Ze gelden dus voor alle auto-objecten.
Definieer daaronder de functie getGarage(). Deze geeft als volgt de garage terug: return Auto.__garage. Een verwijzing naar een static variabele of functie moet altijd beginnen met de classnaam.
Definieer daar de functie setGarage(naam). Deze moet de garage een nieuwe naam geven. Hij retourneert niets. Zorg ervoor de de variabele en functies binnen de class inspringen!

2. Ga in de module een eindje naar beneden en markeer daar het script met --- script ---. maak daaronder de functie testGarage(). Deze hoort niet bij de Auto-class en springt dus niet in! Druk daarin met getGarage() de naam van de garage voor alle auto's af. Wijzig daaronder de garagenaam in 'Van der Veen' met setGarage(). Druk daaronder opnieuw de garagenaam af. Let op: static functies en variabelen beginnen altijd met de classnaam en een punt.
Ga in de module een stukje onder de functie staan en roep daar testGarage() aan, zonder in te springen! Sla de code op. Test. Ga naar testGarage(). Probeer daarin de volgende code: print(Auto.__garage). Werkt dit?

Tot nu toe hebben we slechts static functies en variabelen getest. We kunnen al wel een Auto-object maken, maar krijgen dan een leeg object zonder functionaliteit, omdat we nog geen instance-methoden (functies) en -variabelen voor Auto-objecten hebben gedefinieerd.
Instance-methoden krijgen altijd self als eerste argument; instance-variabelen krijgen altijd self met punt voor hun naam. Dat geldt ook voor instance-methoden die je aanroept vanuit andere instance-methoden. Self verwijst naar het huidige object. Static functies hebben geen self. Ze horen niet bij dit of dat object, maar bij de class als geheel.

Bij de aanroep van een methode in je testcode laat je altijd het argument self weg. In plaats daarvan zet je de naam van je object met punt voor de methode-aanroep.
Om een object te initialiseren en instance-variabelen te declareren gebruiken we altijd de methode __init__(), met tenminste self, maar desgewenst daarachter andere argumenten.

3. Ga naar de class Auto en maak daarin onder de static functies een methode __init__() met argumenten self en eigenaar. De laatste krijgt als default de waarde 'Anon'. Declareer binnen de method vier instance-variabelen: tank met waarde 0, motor met 'uit', merk met '--onbekend--' en eigenaar met het meegegeven argument eigenaar. De instance-variabelen beginnen allemaal met self.
Maak in het script onder de functie testGarage(), maar boven de functie-aanroep, een nieuwe functie testAuto(). Maak daarin een nieuwe auto a1 voor eigenaar 'Jan'. Geef de auto het merk 'Volvo'. Dit doe je met: a1.merk = 'Volvo'. Druk van de auto de eigenaar en het merk af. Druk daaronder de tank en de motor af. Ga in het script helemaal naar beneden, commentarieer de aanroep van testGarage() uit en roep daaronder testAuto() aan. Bewaar en test.


[2] Instance methoden

1. Maak in class Auto een nieuwe instance-methode tanken(), met (naast self) het argument liters. als liters < 1, druk dan af: "Niet getankt." en verlaat de functie met return. De tank heeft een capaciteit van 40 liter. Als de huidige tank + liters boven de 40 uitkomt, verlaag dan liters zodanig dat de tank helemaal gevuld wordt. Druk tenslotte af hoeveel werkelijk getankt is.
Ga naar testAuto(). Tank daar eerst 30 liter en daarna 20 liter. Bij de aanroep van een instance-method moet je self weglaten en alleen verdere argumenten opgeven. Hier dus alleen het aantal liters. Test. Controleer of de tweede keer het juiste aantal liters is getankt.

2. Maak nu in class Auto een instance-methode starten() zonder verdere argumenten. Als de motor al 'aan' staat, druk dan af "Motor staat al aan." Als de motor nog 'uit' staat, zet hem 'aan' en druk af "Motor aangezet."
Maak daaronder de instance-methode stoppen(), eveneens zonder verdere argumenten. Zet hierin de omgekeerde code.
Ga naar testAuto() en schrijf onderaan test code: zet eerst de motor uit (staat al uit), daarna aan, dan weer aan (staat al aan) en tenslotte weer uit. Test.

3. Pas in class Auto starten() aan. Controleer nu eerst of de motor al aan staat en zo nee, daarna of de tank leeg is. Zo ja, druk af "Tank leeg. Kan niet starten." De rest van de code blijft hetzelfde. Test.

4. Maak nu in class Auto een instance-methode rijden() zonder verdere argumenten. Als de motor 'uit' staat, druk dan af "Motor uit. Eerst starten." Als de tank leeg is, druk af "Tank leeg. Eerst tanken." Anders verminder de tank met 1 liter en druk af "We rijden."
Ga naar testAuto() en schrijf onderaan nieuwe test code: ga rijden (motor nog uit), zet motor aan, ga een paar keer rijden, druk tenslotte af hoeveel nog in de tank zit. Test.

5. Maak nu in class Auto een instance-methode sturen() met extra argument koers (bv 'linksaf', 'rechtsaf', 'rechtdoor'. Als de motor 'uit' staat, druk dan af "Motor uit. Eerst starten." Als de tank leeg is, druk af "Tank leeg. Eerst tanken." Anders druk af "Sturen: " met daarachter de koers.
Ga naar testAuto() en schrijf onderaan nieuwe test code: stuur linksaf, blijf rijden, ga rechtdoor, blijf rijden, ga stoppen. Druk tenslotte af hoeveel nog in de tank zit. Test.

6. Tenslotte gaan we de auto verkopen. Voeg onderaan testAuto() code toe. Verander de eigenaar in 'Geesje'. Druk van de auto eigenaar en merk af. Test.


[3] Magic methods en list van Auto-objecten

Een magic method is een methode die begint en eindigt met twee underscores, als argument self meekrijgt, en iets speciaals doet. Onze __init__() is een magic method.

1. Ga naar testAuto() en druk onderaan de auto af met print(a1). Test/ Wat zie je?

2. Maak onderin class Auto de magic method __str__(). Deze moet een string retourneren waarin iets staat over dit object, bv "Geesje heeft een Volvo." met de juiste eigenaar en merk ingevuld.
Test opnieuw. Als het goed is, moet je nu je eigen tekst van __str__() zien langskomen.

3. Voeg nu aan class Auto een magic method __repr__() toe. Deze retourneert ookeen string, maar bij conventie een wat technischer versie, bv voor debug doeleinden. Retourneer hier eigenaar, merk, tank en motor.
Ga naar testAuto() en voeg onderaan toe: print(repr(a1)). Test.
Als je in de Python interpreter een variabele intypt met <Enter>, draait hij achter de schermen ook je __repr__() methode.

4. Zet nu bovenin de class Auto op de eerste regel binnen de class een commentaar met drie quotes: """Een Auto met eigenaar enz."""
Dit wordt een stukje documentatie, dat je kunt uitlezen met het magic attribute __doc__.
Ga naar testAuto() en voeg onderaan toe: print(Auto.__doc__). Test.
Controleer of ook werkt: print(a1.__doc__).
Ga naar de shell en probeer: help(Auto).

5. Maak onder testAuto() een nieuwe functie listAutos(). Maak daarin een list met naam lst en 3 Auto-objecten,met als eigenaars resp. 'John', 'Paul' en 'Mary'.
John krijgt een Porsche, ga tanken met 38 liter.
Paul krijgt een BMW, ga tanken met 34 liter.
Mary krijgt een Trabant, ga tanken met 6 liter.

Print nu in een for-lus alle auto's. Ga naar onderen in het sript, commentarieer de aanroep van testAuto() uit en roep listAutos() aan. Test.

6. Wijzig in listAutos() de lus. Laat alle auto's nu starten, rijden, rechtdoor sturen, weer rijden en dan stoppen. Test.
zet nu direct boven de lus code om de tweede auto (vanaf een, dus eigenlijk auto 1 vanaf 0) te wissen. Test.


[4] Afgeleide class (subclass) VrachtAuto

Een afgeleide class neemt de functionaliteit van een base class over, maar voegt extra functionaliteit toe. De VrachtAuto heeft als extra variabele een lading met bijbehorende instance-methoden.

1. Definieer onder de class Auto een nieuwe class VrachtAuto, die is afgeleid van Auto. Voeg als eerste regel een docstring toe: """VrachtAuto is Auto met lading""".

Definieer in de class een nieuwe __init__() met self en eigenaar met default naam 'Anon'. Roep hierin de __init__()_ van de base class aan: super().__init__(eigenaar)
Declareer binnen __init__() de instance-variabele __lading met waarde '(leeg)'.

2. Maak hieronder een instance-methode inladen() met als extra argument lading (wordt een string). Als de motor 'aan' staat, druk af "Motor aan. Eerst uitzetten." Anders bewaar de ladingin de instance-variabele __lading en druk af ".. ingeladen.", met op de plek van de puntjes de lading.

3. Maak hieronder een instance-methode uitladen() zonder extra argumenten. Als de motor 'aan' staat, druk af "Motor aan. Eerst uitzetten." Als __lading '(leeg)' is, druk af "Vrachtauto leeg. Kan niets uitladen." Anders bewaar __lading in een tijdelijke locale variabele ret, maak __lading '(leeg)', druk af ".. uitgeladen" met op de puntjes de juiste lading, en retourneer ret.

4. Maak hieronder een instance-methode toonLading() zonder extra argumenten. Deze retourneert een string met de tekst "Lading = ..", met op de puntjes de juiste lading.

5. Ga naar beneden in het script en maak onder listAutos() een nieuwe functie testVrachtAuto(). Maak daarin een nieuwe auto v1 voor eigenaar 'Vladimir'. Geef de auto het merk 'Daf'. Toon de lading. Die moet nog '(leeg)' zijn. Laad 25 koelkasten in. Toon weer de lading. Tank 40 liter.
Ga in het script helemaal naar onderen, commentarieer de aanroep van listAutos() uit en roep testVrachtAuto() aan. Test.

6. Ga naar testVrachtAuto() en voeg code toe. Ga starten. Ga rijden. Stuur 'naar Kiev'. Ga door met rijden. Probeer uit te laden naar een locale variabele lad. Druk lad af. Toon de lading van v1. Stop de motor en probeer opnieuw uit te laden naar lad. Druk lad af. Toon de lading van v1. Die moet nu '(leeg)' zijn. Test.

Je ziet in deze oefeningen dat een object bestaat uit state (de instance-variabelen) en behaviour (de instance-methoden). De methoden beïnvloeden de toestand van het object.
